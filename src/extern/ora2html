#!/bin/bash	
# ---------------------------------------------------------
#
#  Ora2html - Oracle database information collector
#  (C) Yngve Clausen 2002-2007
#
#  Version : 1.49pre1
# 
#  This software is released under the GNU Public License
#  Please have a look at the file README and COPYING for more information
#  about licensing, installation and usage.
#
# ---------------------------------------------------------
#
# Author:
# ----------------------------
# Yngve Clausen (yngvec (at) users sourceforge net)
# Oslo, Norway
#
# ---------------------------------------------------------
#
# Description:
# -----------------
# Ora2html is a script for collecting information about oracle databases on a server.
# Output is spooled to either text (stdout) or an html file.
# Explanations and interpreted output is available for some tests.
# Please refer to the file INSTALL for additional information.
#
# ---------------------------------------------------------
#
# Revision history:
# -----------------
#	* See file CHANGELOG for revision history
#
#----------------------------------------------------------------------------------------- 

#---------------------------
# Setup for the shell environment
#---------------------------
set +o noclobber			# Same command as above - another syntax
set -a					# Automagically export subsequent vars
cd $(dirname $0)			# Change to same dir as script resides in

# Save original PATH variable ... We don't need it, but ...
# export DBINFO_ORGPATH=$PATH

# Set the paths we know we need. This will get used in GetSidEnvironment to set PATH later on.
# In the meantime, set PATH=DBINFO_PATH to make sure we can do what we need before that happens.
export DBINFO_PATH=/usr/xpg4/bin:/bin:/sbin:/usr/sbin:/usr/bin:/usr/bin/X11:/usr/local/bin:/usr/ucb:/usr/ccs/bin:/usr/contrib/bin
export PATH=$DBINFO_PATH



#-----------------------------------------------------------------------------------------
#
#                        VERSION INFO
#
#-----------------------------------------------------------------------------------------
export DBINFO_VERSION="1.49"
export DBINFO_RCCS="@(#)ora2html - ver. 1.49"

#-----------------------------------------------------------------------------------------
#
#                        USER CONFIGURABLE PARAMETERS
#
#-----------------------------------------------------------------------------------------
export SQL_LOG=sql.log			# Logfile for sql execution
export DBINFO_SQLLOG=NO			# Disable sql logging by default

#---------------------------
#
# Enable/disable sections of the script
#
#---------------------------
export DBINFO_CHECK_OS=YES
export DBINFO_CHECK_OSUSER=YES
export DBINFO_CHECK_COMPONENTS=YES
# Specifying DBINFO_CHECK_DB=NO also disables the following tests
export DBINFO_CHECK_DB=YES
    export DBINFO_CHECK_BASIC_DB=YES
    export DBINFO_CHECK_STORAGE=YES
    export DBINFO_CHECK_USERS=YES
    export DBINFO_CHECK_OBJECTS=YES
    export DBINFO_CHECK_SESSIONS=YES
    export DBINFO_CHECK_SECURITY=YES
    export DBINFO_CHECK_RMAN=YES

# Some default values
export DBINFO_CHECK_PASSWORD="NO"

export DBINFO_PASSWORD_FILE=accounts.default	# File containing username/password combinations to try if called with -pass

#-----------------------------------------------------------------------------------------
#
#                        NON-CONFIGURABLE PARAMETERS 
#        You probably won't need to change anything below this line ....
#-----------------------------------------------------------------------------------------

#---------------------------
# Set general information - These are default values that shouldn't be altered
#---------------------------
export DBINFO_WORKDIR=$(dirname $0)
export DBINFO_TMP_DIR=$DBINFO_WORKDIR/tmp

#---------------------------
# Set HTML-related information - These are default values that shouldn't be altered
#---------------------------
export DBINFO_OUTPUT=HTML						# Produce output in HTML or TEXT (default is HTML)
export DBINFO_HTML_TOP=$DBINFO_TMP_DIR/html_top.$$.html		 	# temp file containing the html header / shortcuts
export DBINFO_HTML_CONTENTS=$DBINFO_TMP_DIR/html_contents.$$.html	# temp file containing the contents section of the document
export DBINFO_HTML_BOTTOM=$DBINFO_TMP_DIR/html_bottom.$$.html	 	# temp file containing the data / htmlfooter 
export DBINFO_HTML_TABLES=YES					  	# Don't produce tables in HTML 
export DBINFO_HTML_STATUS=$DBINFO_TMP_DIR/html_status.$$.txt	  	# Status html document
export DBINFO_POPDIR=help					  	# Directory to create popup sql source documents 
export DBINFO_POP=NO
# ------------------

# Main html document
export DBINFO_HTML_DOC=$DBINFO_WORKDIR/$(uname -n | cut -d"." -f1)_oracle_$(date '+%Y%m%d-%H%M').html		
# Default format of html tables
export DBINFO_HTML_TAB_FORMAT="border=1 width=95% cellpadding=1 align=center" 

export DBINFO_EXPIRE_CACHE=`LC_TIME="" date "+%a, %d %b %Y "`"23:00 GMT"


#---------------------------
# Set hardware/OS-dependant default variables:
# These are changed later on according to platform/OS later on
# - Path to files
# - Path to spesific executables we need
# - Special commandline options
# - Command strings (used by an 'eval' further down)
# - Default values if not a known system type
#---------------------------
export DBINFO_ORATAB=/etc/oratab	# Default value for oratab location
export DBINFO_KERNEL_INFO=true		# Default value for kernel parameter information command
export DBINFO_SWAP_INFO="unknown"	# Default value for swap info command
export DBINFO_MEM_INFO="unknown"	# Default value for memory info command
export DBINFO_OS_REL=$(uname -r)	# Default value for OS Release command
export DBINFO_OS_VER=$(uname -v)	# Default value for OS version/revision command

#---------------------------
# OS SPESIFIC SETUP !!
#---------------------------
export DBINFO_CPUCOUNT=""		# Number of processors on this server
export DBINFO_DOMAIN_NAME=$(grep ^domain /etc/resolv.conf 2>/dev/null | awk '{print $2}')
case $(uname -s) in
    AIX )   alias df="df -k"
            DBINFO_KERNEL_INFO="echo Name=Value;grep -E \"set shm|set sem\" /etc/system"
            DBINFO_MEM_INFO=$(/usr/sbin/lsattr -El mem0 | awk '{ print $2, $9, $1 }' | grep good)
            DBINFO_SWAP_INFO=$(/usr/sbin/lsps -a)
            DBINFO_ORATAB=/etc/oratab
            DBINFO_CPUCOUNT=$(lscfg |grep proc|wc -l)
            DBINFO_CPUTYPE=$(/usr/bin/uname -p)
            # Don't know if these ones work ...
            DBINFO_IP_ADR=$(nslookup $(uname -n) | awk ' $1 == "Address:" {ip=$2} END {print ip}')
            DBINFO_HWTYPE=$(uname -m)
            DBINFO_HWWORD=""
            DBINFO_OSWORD=""
            # Only local filesystems
            DBINFO_STORAGE_SIZE=$(df -k -l | grep -v Filesystem | awk '{sum += $2 } END { printf "%i M\n",sum/1024; }')
            # Only taking info from first processor ...
            DBINFO_CPUFAMILY=$(/usr/sbin/lsattr -El proc0|grep type|awk '{ print $2 }');; 
    SunOS ) alias grep=/usr/xpg4/bin/grep
            alias awk=/usr/bin/nawk
            alias id=/usr/xpg4/bin/id
            alias df="df -k"
            DBINFO_KERNEL_INFO="echo Name=Value;grep -E \"set shm|set sem\" /etc/system"
            DBINFO_IP_ADR=$(nslookup $(uname -n) | awk ' $1 == "Address:" {ip=$2} END {print ip}')
            DBINFO_MEM_INFO=$(/usr/sbin/prtconf | awk ' $1 == "Memory" {print $3" M"}')
            DBINFO_SWAP_INFO=$(swap -s | tr -d k | awk '{printf "%d M\n",$2/1024}')
            DBINFO_ORATAB=/var/opt/oracle/oratab
            DBINFO_HWTYPE=$(/usr/platform/$(uname -i)/sbin/prtdiag | sed 's/sun4u /%/g' | cut -d"%" -f2 | head -1)
            DBINFO_HWWORD=$(/usr/bin/isainfo -b)
            DBINFO_OSWORD=$(/usr/bin/isainfo -kv | cut -d"-" -f1)
            DBINFO_CPUCOUNT=$(/usr/sbin/psrinfo | awk 'END {print NR}')
            DBINFO_CPUTYPE=$(/usr/bin/uname -p)
            # Only taking info from first processor ...
            DBINFO_CPUFAMILY=$(/usr/sbin/psrinfo -v | awk 'NR == 3 {print $2}')
            # Only local filesystems
            DBINFO_STORAGE_SIZE=$(df -k -l | grep -v Filesystem | awk '{sum += $2 } END { printf "%i M\n",sum/1024; }');;
    HP-UX ) # This one isn't nice ....
            alias df=HPUXdf
            DBINFO_KERNEL_INFO='/usr/sbin/kctune | grep -v = | tr -s " " | tr " " "="'
            DBINFO_IP_ADR=$(nslookup $(uname -n) | awk ' $1 == "Address:" {ip=$2} END {print ip}')
            DBINFO_SWAP_INFO=$(/usr/sbin/swapinfo -dm | awk ' END {print $2 " M"}')
            DBINFO_CPUCOUNT=$(/usr/sbin/ioscan -k|grep processor|wc -l)
            DBINFO_HWWORD=$(getconf HW_CPU_SUPP_BITS)
            DBINFO_OSWORD=$(getconf KERNEL_BITS)
            DBINFO_HWTYPE=$(getconf MACHINE_MODEL)
            # Alternative methods :
            #DBINFO_HWTYPE=$(/usr/contrib/bin/machinfo | tr -d "\"" | awk ' $1$2 == "modelstring" {sub(".*= *","");print}'
            #DBINFO_HWTYPE=$(/usr/bin/model | awk '{print $NF}')
            #DBINFO_HWTYPE=$(uname -m)
            # Rely on machinfo to get us what we need, if it's present
            # Machinfo is only present for ia64 v.11.23+ systems
            if [ -x /usr/contrib/bin/machinfo ] ; then
                    DBINFO_MEM_INFO=$(/usr/contrib/bin/machinfo | awk ' $1 == "Memory" {print $3" M"}')
                    DBINFO_CPUFAMILY=$(/usr/contrib/bin/machinfo | grep "processor model:" | cut -c43-)
                    DBINFO_CPUTYPE=$(/usr/contrib/bin/machinfo | awk ' $1$2 == "machine=" {print $3}')
            else
                    DBINFO_MEM_INFO=$(head -l -n 1200 /var/adm/syslog/syslog.log |grep Physical | sed 's/.*Physical: //' | awk '{printf "%i M\n",$1/1024}')
                    DBINFO_CPUFAMILY=$(grep `model|cut -f3 -d/` /usr/sam/lib/mo/sched.models)
                    DBINFO_CPUTYPE=$(grep `model|cut -f3 -d/` /usr/sam/lib/mo/sched.models)
                    if [ "$DBINFO_CPUTYPE" = "" ] ; then
                            DBINFO_CPUTYPE=$(uname -m)
                    fi
            fi
            # Only local filesystems
            DBINFO_STORAGE_SIZE=$(bdf -l | grep -v Filesystem | awk '{sum += $2 } END { printf "%i M\n",sum/1024; }');;
    OSF1  ) alias df="df -k"
            DBINFO_KERNEL_INFO="/sbin/sysconfig -q ipc"
            DBINFO_IP_ADR=$(nslookup $(uname -n) | awk ' $1 == "Address:" {ip=$2} END {print ip}')
            DBINFO_MEM_INFO=$(/usr/bin/vmstat -P | grep ^Total | awk '{printf "%i M\n",$5}')
            DBINFO_SWAP_INFO=$(/sbin/swapon -s | tr -d "()GB" | awk ' $1 ~ "Allocated" {s=$NF} END {print s" G"}')
            DBINFO_CPUCOUNT=$(/usr/sbin/sizer -p)
            DBINFO_CPUTYPE=$(/usr/bin/uname -p)
            DBINFO_CPUFAMILY=$(/usr/sbin/sizer -implver)
            DBINFO_OS_REL=$(/usr/sbin/sizer -v | awk '{print $4}')
            DBINFO_HWTYPE=$(strings /etc/dec_hwc_ldb | grep -i alpha | tail -1)
            DBINFO_HWWORD=64
            DBINFO_OSWORD=64
            # Make sure df can be used with the -t option (CMD_ENV=xpg4 requires -F instead)
            unset CMD_ENV
            # Only local filesystems
            DBINFO_STORAGE_SIZE=$(df -k -t nonfs | grep -v Filesystem | awk '{sum += $2 } END { printf "%i M\n",sum/1024; }');;
    Linux )	alias echo="echo -e"
            alias grep=/bin/grep
            alias df="df -k"
            if [ -x /usr/bin/getconf ] ; then
            	DBINFO_OSWORD=$(/usr/bin/getconf LONG_BIT)
            fi
            if [ -r /proc/cpuinfo ] ; then
                    # Check if processors supports long mode
                    grep flags /proc/cpuinfo | grep -q -w lm
                    if [ $? -eq 0 ] ; then
                            DBINFO_HWWORD=64
                    else
                            DBINFO_HWWORD=32
                    fi
            fi

            DBINFO_KERNEL_INFO="echo Name=Value;/sbin/sysctl -a 2>/dev/null | grep -E \"kernel.shm|kernel.sem\""

	    # Some distribs might not report memory completely accurate
            # dmidecode should be pretty accurate if we are allowed to use it
            if [ -x /usr/sbin/dmidecode -a "$(id -nu)" = "root" ] ; then
                    DBINFO_MEM_INFO=$(dmidecode | awk '/Physical Memory Array/,/Memory Array Mapped/' \
                            | awk ' $1 == "Size:" {sum = sum+$2} END {print sum" M"}')
            else
                    DBINFO_MEM_INFO=$(/usr/bin/free | awk ' $1 == "Mem:" {printf "%i M\n",$2/1024}')
            fi

            DBINFO_SWAP_INFO=$(/usr/bin/free | awk ' $1 == "Swap:" {printf "%i M\n",$2/1024}')

            # Physical CPU's
            DBINFO_CPUCOUNT=$(cat /proc/cpuinfo | grep ^physical | sort -u | awk 'END {print NR}')
            # CPU cores
            DBINFO_CPUCORECOUNT=$(cat /proc/cpuinfo | grep ^processor | awk 'END {print NR}')

            if [ "$DBINFO_CPUCORECOUNT"  != "$DBINFO_CPUCOUNT" ] ; then
		DBINFO_CPUCOUNT="$DBINFO_CPUCOUNT ($DBINFO_CPUCORECOUNT Cores)"
            fi

            DBINFO_CPUTYPE=$(cat /proc/cpuinfo | sort -u | grep ^vendor_id | awk '{print $3}')
            DBINFO_CPUFAMILY=$(cat /proc/cpuinfo | sort -u | grep "model name" | awk -F ": " '{print $2}')
#           DBINFO_CPUFAMILY=$(cat /proc/cpuinfo | sort -u | grep -E "cpu family|model name" |cut -d: -f2 | sed 'N;s/\n/ \//;p;d')

            # Take a stab at guessing ip adress. Start at best approach and continue downwards
            DBINFO_IFACE=$(awk '$2 == 00000000 {print $1}' /proc/net/route 2>/dev/null)
            if [ "$DBINFO_IFACE" != "" ] ; then
		DBINFO_IP_ADR=$(ifconfig $DBINFO_IFACE | tr ":" " " | awk ' $0 ~ /inet addr/ {print $3}')
            else
		DBINFO_IP_ADR=$(nslookup $(uname -n) 2>/dev/null  | awk ' $1 == "Address:" {ip=$2} END {print ip}')
            fi

            DBINFO_HWTYPE=$(uname -m)
            # Quick hack for Linux - OS version and release swaps place
            # Release is fetched from the release-spesific file under /etc/
            DBINFO_OS_VER=$(uname -r)

            # Get release names ... starting from most certain and head on down ..
            if [ -x /etc/lsb-release ] ; then
           	 . /etc/lsb-release
            	DBINFO_OS_REL=$DISTRIB_DESCRIPTION
            elif [ -x /usr/bin/lsb_release ] ; then
            	DBINFO_OS_REL=$(lsb_release -sd)
            else
            	OUTPUT=$(ls -1 /etc/* 2>/dev/null | grep -E "_version|-version|-release" | head -1)
            	if [ "$OUTPUT" != "" ] ; then
                    DBINFO_OS_REL=$(head -1 $OUTPUT)
            	else
                    DBINFO_OS_REL="Custom"
            	fi
            fi

            # If dnsdomainname returns anything, use it instead of any DOMAIN_NAME set so far
            TMP=$(/bin/dnsdomainname 2>/dev/null)
            if [ "$TMP" != "" ] ; then
                    DBINFO_DOMAIN_NAME=$TMP
            fi
            # Only local filesystems
            DBINFO_STORAGE_SIZE=$(df -k -P -x nfs | grep -v Filesystem | awk '{sum += $2 } END { printf "%i M\n",sum/1024; }')
            # We need echo -e or xpg_echo for escaped chars to work on Linux ... If we're running bash.
            if [ "$SHELL" = "bash" ] ; then
                shopt -s xpg_echo
            fi;;
    * )	echo "Unable to find system type. This may cause problems ...";;
esac


#---------------------------
#
# Other variables
#
#---------------------------

# Should we print background information on some of the tests we perform?
export DBINFO_EXPLAIN=NO

# Count encountered problems while executing the script
typeset -i DBINFO_ERRORS=0

# Initialize some parameters for later use ...
export DBINFO_CHECKSIDS=""		# Which db's to check
export DBINFO_UL_LAST=1			# Used for generating nice html unstructured list - keeps track of indent of last item
typeset -i DBINFO_RETURNED_ROWS=0	# Number of rows returned by an sql statement
export DBINFO_LISTENER_SHARED=""	# Stor name of shared listener file (if any)
export DB_ORAINST_FILE=""		# Location of oraInst.loc file
export DBINFO_OHALL=""			# List of all ORACLE_HOMEs on the server
export DBINFO_HOME="used"		# Default behaviour is to list contents for all ORACLE_HOME's 
export inventory_loc=""
export inst_group=""

#---------------------------
#
# Unset / Set these to make sure we get no connect problems
#
#---------------------------
unset TWO_TASK
export ORAENV_ASK="NO" 

#####################################################################
#####################################################################
#####                                                           #####
#####               F  U  N  C  T  I  O  N  S                   #####
#####                                                           #####
#####################################################################
#####################################################################

#---------------------------
# Make a df command for HPUX that resembles what other OS'es make
# This solution isn't too nice, but ...
#---------------------------
HPUXdf ()
        {
        /usr/bin/df -Pkl $* \
		| awk ' NF == 1 {printf "%s",$1} NF != 1  {print $0}' \
		| awk '{printf "%-35s %12s %10s %10s %10s %s %s\n",$1,$2,$3,$4,$5,$6,$7}'
        return $?
        }


#---------------------------
# Common exit procedure 
# Input : (1) Errorcode (2) Exitmessage
# Output: (1) Exitcode  (2) Exitmessage
#---------------------------
ExitScript ()
    {
    if [ "$DBINFO_OUTPUT" = "TEXT" ] ; then
        echo "\n######################################################################################"
        echo "# Report status :"
        echo "######################################################################################\n"
        if [ -f $DBINFO_HTML_STATUS ] ; then
            cat $DBINFO_HTML_STATUS
            rm -f $DBINFO_HTML_STATUS
        else
            echo "No issues"
        fi
        echo "\n$1 : $2"
    fi
    if [ "$DBINFO_OUTPUT" = "HTML" ] ; then
        HtmlFooter
        echo "HTML file $DBINFO_HTML_DOC created"
        echo "============================================================================"
        echo "Finished : $(date)"
        exit 0
    fi
    exit $1
    }

#---------------------------
# Common errormessage procedure
# Input : (1) Errorcode (2) Exitmessage
# Output: (1) Errorcode (2) Exitmessage
#---------------------------
Error ()
    {
    [ "$DBINFO_OUTPUT" = "TEXT" ] && echo "!! Error $1 : $2"
#	[ "$DBINFO_OUTPUT" = "HTML" ] && echo "<FONT COLOR=red><B>!! Error $1 : $2</FONT></B><br>\n" >> $DBINFO_HTML_BOTTOM
    [ "$DBINFO_OUTPUT" = "HTML" ] && AddText warning "!! Error $1 : $2" 
    echo "$ORACLE_SID : !! Error : $2" >> $DBINFO_HTML_STATUS
    let DBINFO_ERRORS+=1
    return $1
    }

#---------------------------
# Create the required sub directories
# Input : None
# Output: Errorcode 
#---------------------------
MkDir ()
    {
    if [ ! -d $DBINFO_TMP_DIR ] ; then
        mkdir $DBINFO_TMP_DIR || return 1
    fi
    if [ "$DBINFO_POP" = "YES" -a ! -d $DBINFO_POPDIR ] ; then
        mkdir $DBINFO_POPDIR || return 1
        # Clean the directory
        rm -f $DBINFO_POPDIR/sql_*.html || return 1
    fi
    }

#---------------------------
# Common func to exec other functions with 
# calls to html-generating code.
# Input : (1) Indendation 
#	  (2) Paragraph heading 
#	  (3) Function to exec 
# Output: (1) Errorcode
#---------------------------
Exec ()
    {
    if [ "$DBINFO_OUTPUT" = "HTML" ] ; then
        echo "Collecting : $2 - $3 ..."
        HtmlSectionHeader $1 "$2"
        if [ "$3" != "" ] ; then
            echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
            $3 >> $DBINFO_HTML_BOTTOM
            DBINFO_EC=$?
            echo "</PRE>" >> $DBINFO_HTML_BOTTOM
        fi
        return $DBINFO_EC
    fi

    [ "$DBINFO_OUTPUT" = "TEXT" ] && TextSectionHeader $1 "$2"
    $3 
    return $?
    }

#---------------------------
# Print section header
# Input : (1) Header size
#	  (2) String to print to stdout
# Output: String to print to stdout
#---------------------------
TextSectionHeader ()
    {
    case $1 in
        H1)	DBINFO_BAR="################################################################################";;
        H2)	DBINFO_BAR="###################################################################";;
        H3)	DBINFO_BAR="######################################################";;
        H4)	DBINFO_BAR="############################################";;
    esac
    echo "\n$DBINFO_BAR\n# $2\n$DBINFO_BAR\n"
    return $?
    }

#---------------------------
# Print section header in HTML
# Input : (1) Header size
#	  (2) String to print to stdout
# Output: String to print to stdout
# The header size is compared to the header used last time 
# this function was called. If it has changed, either
# increase or decrease the html UL indentation
# (unordered list)
#---------------------------
HtmlSectionHeader ()
    {
    echo "<A NAME=\"$2\"><$1> $2 </$1></A>" >> $DBINFO_HTML_BOTTOM

    # Update content section of html document
    DBINFO_UL_CUR=$(echo $1 | cut -c2)
    # Decrease indent
    if  [ $DBINFO_UL_LAST -gt $DBINFO_UL_CUR ] ; then
        typeset -i i=$DBINFO_UL_CUR
        while [ $i -lt $DBINFO_UL_LAST ] ; do
            echo "</UL>\c" >> $DBINFO_HTML_CONTENTS
            let i+=1
        done
        echo "" >> $DBINFO_HTML_CONTENTS
    # Increase indent	
    elif [ $DBINFO_UL_LAST -lt $DBINFO_UL_CUR ] ; then
        typeset -i i=$DBINFO_UL_LAST
        while [ $i -lt $DBINFO_UL_CUR ] ; do
            echo "<UL>\c" >> $DBINFO_HTML_CONTENTS
            let i+=1
        done
        echo "" >> $DBINFO_HTML_CONTENTS
    fi
    echo "<A HREF=\"#$2\">$2</A><BR>" >> $DBINFO_HTML_CONTENTS
    DBINFO_UL_LAST=$DBINFO_UL_CUR
    return $?
    }



#---------------------------
# Print HTML document header 
# Input : none
# Output: String to print to stdout
#---------------------------
HtmlHeader ()
    {
    # Top of page
    # Use the default Oracle CSS
    # Don't use image background - stick with grey
    echo "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">
    <HTML> <HEAD>
    <META NAME=\"GENERATOR\" CONTENT=\"$DBINFO_RCCS\">
    <META NAME=\"CHANGED\" CONTENT=\"`id`\">
    <META NAME=\"DESCRIPTION\" CONTENT=\"$(basename $0) ver. $DBINFO_VERSION $(date)\">
    <META NAME=\"SUBJECT\" CONTENT=\"ora2html.sh $DBINFO_VERSION on $(uname -n)\">
    <META HTTP-EQUIV=\"expires\" CONTENT=\"${DBINFO_EXPIRE_CACHE}\">" >| $DBINFO_HTML_TOP || return $?

    if [ "$DBINFO_CSS" = "" ] ; then
    echo "<style type='text/css'> 
        body {font:10pt Arial,Helvetica,sans-serif; color:black; background:White;} 
        p {font:10pt Arial,Helvetica,sans-serif; color:black; background:White;} 
        table,tr,td {font:10pt Arial,Helvetica,sans-serif; color:Black; background:#f7f7e7; padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;} 
        th {font:bold 10pt Arial,Helvetica,sans-serif; color:#336699; background:#cccc99; padding:0px 0px 0px 0px;} 
        h1 {font:16pt Arial,Helvetica,Geneva,sans-serif; color:#336699; background-color:White; border-bottom:1px solid #cccc99; margin-top:0pt; margin-bottom:0pt; padding:0px 0px 0px 0px;} 
        h2 {font:bold 10pt Arial,Helvetica,Geneva,sans-serif; color:#336699; background-color:White; margin-top:4pt; margin-bottom:0pt;} 
        a {font:9pt Arial,Helvetica,sans-serif; color:#663300; background:#ffffff; margin-top:0pt; margin-bottom:0pt; vertical-align:top;}
        a.l {font:9pt Arial,Helvetica,sans-serif; color:#663300; background:#cccc99; margin-top:0pt; margin-bottom:0pt; vertical-align:top;}
        td.tabtop {text-align:center; font:14pt Arial,Helvetica,sans-serif; color:#f7f7e7; background:#336699; padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;}
        font {font:bold 10pt Arial,Helvetica,sans-serif; color:#336699;} 
        font.info {font:bold 10pt Arial,Helvetica,sans-serif; color:green;} 
        font.warning {font:bold 10pt Arial,Helvetica,sans-serif; color:red;} 
        font.htmlhead {font:bold 40pt Arial,Helvetica,sans-serif; color:#336699;} 
        font.htmlheadmed {font:bold 20pt Arial,Helvetica,sans-serif; color:#336699;} 
        font.htmlheadsmall {font:bold 8pt Arial,Helvetica,sans-serif; color:#336699;}
    </style>" >> $DBINFO_HTML_TOP || return $?
    else
	echo "<link rel=\"stylesheet\" type=\"text/css\" href=\"$DBINFO_CSS\"/>" >> $DBINFO_HTML_TOP || return $?
    fi
    echo "<TITLE>Oracle System Documentation - ver. $DBINFO_VERSION</TITLE>
    <SCRIPT LANGUAGE=\"JavaScript\" TYPE=\"text/javascript\">
        function popup(name) {
            win=window.open(\"help/sql_\" + name + \".html\",\"Sql source \"  + name + \"\" ,\"toolbar=0,scrollbars=1,location=0,statusbar=0,menubar=0,resizable=1,width=600,height=600\");
            if (win.opener == null){win.opener = self;}
            win.focus();
        }
    </SCRIPT>
    </HEAD>
    <BODY LINK=\"#0000ff\" VLINK=\"#800080\">
    <H1>
    <table align=center width=99% border=5><TR><TH>
    <font class=htmlhead>Oracle System Documentation</font>
        <BR><BR>
    <font class=htmlheadmed>$(uname -n)</font><font class=htmlheadsmall>&nbsp( $(uname -s) - $(uname -r) )</font>
        <BR><BR>
        <font class=htmlheadsmall>Created $(date) using <a href=http://ora2html.sourceforge.net class=l>ora2html</a> ver. $DBINFO_VERSION<BR><BR></font>
    </TH></TR></table>
    </H1><BR>
    Jump to : " >> $DBINFO_HTML_TOP || return $?

    # Start status section
    echo "<A NAME=\"Report summary\"><H1> Report summary </H1></A><PRE>" >|  $DBINFO_HTML_STATUS || return $?

    # Start contents section
    echo "<H1>Contents</H1>\n<A HREF=\"#Report summary\">Report Summary</A><BR><BR>" >| $DBINFO_HTML_CONTENTS 
    return $?
    }

#---------------------------
# Print HTML document footer
# Input : none
# Output: String to print to stdout
#---------------------------
HtmlFooter ()
    {
    # End html header section with a line
    echo "<A HREF=\"#Report summary\">[Summary]</A><HR>" >> $DBINFO_HTML_TOP

    # End contents section of html page
    # Close the UL list ... End with a line
        if  [ $DBINFO_UL_LAST -gt 1 ] ; then
                typeset -i i=1
                while [ $i -lt $DBINFO_UL_LAST ] ; do
                        echo "</UL>\c" >> $DBINFO_HTML_CONTENTS
                        let i+=1
                done
    fi
    echo "<HR>" >> $DBINFO_HTML_CONTENTS

    # Close html footer 
    echo "<HR><CENTER><FONT>Created $(date) using ora2html $DBINFO_VERSION by <A HREF="mailto:yngvec@users.sourceforge.net?subject=ora2html_$DBINFO_VERSION">yngvec</A></FONT></CENTER>" >> $DBINFO_HTML_BOTTOM
    echo "<HR><CENTER><A HREF="http://ora2html.sourceforge.net">  [ Ora2html homepage ] </B></A></CENTER>" >> $DBINFO_HTML_BOTTOM
    echo "<HR></BODY></HTML>" >> $DBINFO_HTML_BOTTOM

    # Update status section of html page
    echo "</PRE><HR>" >> $DBINFO_HTML_STATUS

    # Merge all html files
    cat $DBINFO_HTML_TOP $DBINFO_HTML_CONTENTS $DBINFO_HTML_STATUS $DBINFO_HTML_BOTTOM >| $DBINFO_HTML_DOC || return $?
    rm -f $DBINFO_HTML_TOP $DBINFO_HTML_BOTTOM $DBINFO_HTML_CONTENTS $DBINFO_HTML_STATUS

    return $?
    }

#---------------------------
# Print to screen specified text
# Input : (1) css class ( std for none)
#	  (2) Text string to print
# Output: String to print to stdout
#---------------------------
AddText ()
    {
    # If in text-mode
    [ "$DBINFO_OUTPUT" = "TEXT" ] && echo "$2"
    # If in html-mode 
    if [ "$DBINFO_OUTPUT" = "HTML" ] ; then
        [ "$1" = "std" ] && echo "<FONT>$2</FONT>" >> $DBINFO_HTML_BOTTOM
        [ "$1" != "std" ] && echo "<FONT CLASS=$1>$2</FONT>" >> $DBINFO_HTML_BOTTOM
    fi
    return $?
    }

#---------------------------
# Run specified sql 
# Input : (1) pagesize 
#	  (2) Report Header text ("-") means none
#	  (3) String to run
# Output: Output of command
#---------------------------
RunSql ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        9*|1*)	export DBINFO_LOGIN="/ as sysdba";;
        *)	export DBINFO_LOGIN="internal";;
    esac

    [ "$2" = "-" ] || echo "$2\n----------------------------------------------------------------------------------"

    # Run sql, setting some default values for page setup. Feedback is on by default, to ensure the 
    # query returns number of rows selected.
    # OK to return result + 'no rows returned' ... strip blank lines and all other info ...
    SQL_OPT="set pages $1 lines 300 feedback on timing off trimspool on"

    # SQL logging if activated :
    LogSql start "$2" "whenever sqlerror exit sql.sqlcode\n$SQLOPT\n$3"

    # Run SQL
    echo "whenever sqlerror exit sql.sqlcode\nset pages $1 lines 300 feedback on timing off\n$3" | \
        sqlplus -s "$DBINFO_LOGIN" >| $DBINFO_TMP_DIR/dbinfo.tmp.$$  || return $?

    grep -v -E "^$|[0-9] row[s]* selected|PL/SQL procedure successfully" $DBINFO_TMP_DIR/dbinfo.tmp.$$

    # Update DBINFO_RETURNED_ROWS with # of rows select statement returned
    DBINFO_TEMP=$(grep -E "row[s]* selected"  $DBINFO_TMP_DIR/dbinfo.tmp.$$ | awk '{print $1}')
    if [ "$DBINFO_TEMP" = "no" -o "$DBINFO_TEMP" = "" ] ; then
        DBINFO_RETURNED_ROWS=0
    else
        DBINFO_RETURNED_ROWS=$DBINFO_TEMP
    fi

    # SQL logging if activated :
    LogSql stop $DBINFO_RETURNED_ROWS $DBINFO_TMP_DIR/dbinfo.tmp.$$
    # SQL Logging :

    rm -f $DBINFO_TMP_DIR/dbinfo.tmp.$$
    return 0
    }

#---------------------------
# Print out a header table 
# (Used in front of tables
# generated by either sqlplus -M or Col2Html)
# Input : (1) Text to print inside tablecell
# Output: Html code
#---------------------------
HtmlTabHeader ()
    {
    echo "<table $DBINFO_HTML_TAB_FORMAT><tr><td CLASS=tabtop>"
    echo "		<B>$1</B></td></tr></table>"
    }

#---------------------------
# Create Html table of inpout data (stdin)
# NOTE : pipe data into this function ...
# Input : (1) Table header name ( - for none)
#         (2) [COLHEAD|NOCOLHEAD] - First row conatins column headers
#         (3) Force specified alignment on all columns (right | left | center | dynamic)
#         (4) data delimiter (single character) if other than " "
# Output: Html code
#---------------------------
Col2Html ()
    {
    # Since we're inside a PRE tag - turn it off to ensure nice table formatting
    echo "</PRE>"
    [ "$1" != "-" ] && HtmlTabHeader "$1"
    if [ "$4" = "" ] ; then
        DELIMITER=" "
    else
        DELIMITER="$4"
    fi	
        # Print html code for start of table definition
        echo "<table $DBINFO_HTML_TAB_FORMAT><TR>"

    # Truncate all successive whitespace to a single whitespace
    # and call awk to html-ize data source
    # In the main body of data, fields containing letters,  / or \ will be
    # default justified, all others will be right justified
    # Unless $4 specifies another alignment for all data
    if [ "$3" = "" -o "$3" = "dynamic" ] ; then
        C_ALIGN=""
    else
        C_ALIGN="$3"
    fi
    
    sed 's/ / /g' | tr -s " " | awk -v TCH=$2 -v C_ALIGN="$C_ALIGN" -F "$DELIMITER" \
        '
        TCH == "COLHEAD" && NR == 1 {
            print "<TR>";
            for(i=1;i<=NF;i++) print "<TH scope=col>"$i"</TH>";
            print "</TR>"}
        TCH != "COLHEAD" || NR > 1 {
            print "<TR>";
            for(i=1;i<=NF;i++) { 
                if ($i == " " || length($i) == 0 ) $i="&nbsp";
                if ( C_ALIGN  == "" ) {
                    if ( $i ~ /[a-zA-Z\/\\]/)
                        print "<TD >"$i"</TD>";
                    else
                        print "<TD align=right>"$i"</TD>";}
                else
                    print "<TD align="C_ALIGN">"$i"</TD>";
                };
            print "</TR>"}
        ' || return $?
    # End table
    echo "</table>"
    # Reset PRE tag
    echo "<PRE>"
    return $?
    }

#---------------------------
# Log sql execution to file
# Input : (1) [start] of logging
#         (2) Report header text
#         (3) SQL statement
# Or:
# Input : (1) [stop] of logging
#         (2) Number of rows returned by query
#         (3) File containing sql output
# Output: text to default sql logfile
#---------------------------
LogSql ()
    {
    if [ "$DBINFO_SQLLOG" = "YES" ] ; then
        case $1 in
            start)	echo "\n--------------------------------------------\nRunSql2Html $2" >> $SQL_LOG
                echo "Login  =  $DBINFO_LOGIN" >> $SQL_LOG
                echo "Text   =" >> $SQL_LOG
                echo "$3" | sed 's/	//;s/^[ ]*/     /' >> $SQL_LOG;;
            stop)	echo "\nReturned" >> $SQL_LOG
                echo "Rows   = $2" >> $SQL_LOG
                echo "Data   =" >> $SQL_LOG
                cat $3 | sed 's/	//;s/^[ ]*/     /' >> $SQL_LOG;;
        esac
    fi
    return $?
    }

#---------------------------
# Run specified sql and format output
# as a HTML table. If _no_ html output is enabled,
# call function RunSql instead.
# If pagesize is 0, then no column headers will be assumed.
# Input : (1) pagesize 
#	  (2) Report Header text ("-") means none
#	  (3) String to run
# Output: Output of command
# Note  : Due to the Exec function, we're inside a <PRE> declaration here
# Note2 : 9i databases uses sqlplus -MARKUP to generate html tables
#         Previous versions uses Col2Html
#         This solution is quite confusing, and pretty messy ...
#---------------------------
RunSql2Html ()
    {
    if [ "$DBINFO_OUTPUT" != "HTML" -o "$DBINFO_HTML_TABLES" != "YES" ] ; then
        RunSql "$1" "$2" "$3"
        return $?
    fi

    case $DBINFO_DB_VERSION_SHORT in
        9*|1*)	export DBINFO_LOGIN="/ as sysdba"
            SQLOPT="set lines 300 pages $1 feedback on timing off appinfo ora2html trimspool on"
            HTMLOPT="HTML ON SPOOL OFF TABLE '$DBINFO_HTML_TAB_FORMAT'";;
        *)	export DBINFO_LOGIN="internal"
            SQLOPT="set pages $1 lines 300 feedback on timing off appinfo ora2html colsep ^ trimspool on";;
    esac

    # For Col2Html conversion  ...
    if [ $1 -eq 0 ] ; then
        SQLOPT="$SQLOPT head off"
        COLHEAD=NOCOLHEAD
    else
        COLHEAD=COLHEAD
    fi

    # If we're requested to dump sql query source, do it here ...
    if [ "$DBINFO_POP" = "YES" -a "$2" != "-" ] ; then
        n=$(echo "$2" | tr -d " /\$")
        echo "<A HREF=\"JavaScript:popup('$n')\">[sql]</A>"
        echo "<HTML><HEAD><TITLE>$2</TITLE><BODY BGCOLOR=\"#FFFFFF\"  COLOR="#f7f7e7">
        <TABLE WIDTH=\"90%\" BORDER=\"1\" CELLPADDING=\"1\"><TR>
        <TD ALIGN=\"CENTER\" BGCOLOR=\"#4480C6\"><FONT FACE=\"Arial\" SIZE=\"4\"><B>$2</B></FONT></TD>
        </TR></TABLE><PRE>\n$(echo "$3" | sed 's/^ *//')\n</PRE></BODY></HTML>" >| $DBINFO_POPDIR/sql_$n.html
    fi
    # SQL logging if activated :
    LogSql start "$2" "whenever sqlerror exit sql.sqlcode\n$SQLOPT\nspool $DBINFO_TMP_DIR/dbinfo.tmp.$$\n$3"

    # Turn of PRE tag set by Exec function. It looks OK in IE without this, but Opera leaves a gap
    # between the table header and the table contents (They are 2 separate tables)
    echo "</PRE>"

    # 1 )  Run sql. Feedback is on by default, to ensure the query returns number of rows selected.
    #      Note : sqlplus htlm opt: preformat on | off   (off default)
    #             sqlplus htlm opt: entmap on | off   (on default)
    # 2 )  Dump result to stdout; OK to return result + 'no rows returned' ... strip blank lines and all other info ...
    case $DBINFO_DB_VERSION_SHORT in
        9*|1*) 	echo "whenever sqlerror exit sql.sqlcode\n$SQLOPT\nspool $DBINFO_TMP_DIR/dbinfo.tmp.$$\n$3" | \
            sqlplus -s -m "$HTMLOPT" "$DBINFO_LOGIN" > /dev/null || return $?
            # Choose wether html table should have a separate header table or not 
            # ... Print separate header if it has
            [ "$2" != "-" ] && HtmlTabHeader "$2"
            # Dump sqlcode generated by sqlplus -m, strip empty lines and <p> tags
            cat $DBINFO_TMP_DIR/dbinfo.tmp.$$ | grep -v -E "^[0-9]* row[s]* selected|^$|^<p>$";;
        *)  	echo "whenever sqlerror exit sql.sqlcode\n$SQLOPT\nspool $DBINFO_TMP_DIR/dbinfo.tmp.$$\n$3" | \
            sqlplus -s "$DBINFO_LOGIN" >> /dev/null  || return $?
            # Convert 8i output to html table by calling Col2Html
            grep -v -E "^---|^$|[0-9] row[s]* selected" $DBINFO_TMP_DIR/dbinfo.tmp.$$ | \
                        Col2Html  "$2" $COLHEAD dynamic "^";;
    esac
    
    # Update DBINFO_RETURNED_ROWS with # of rows select statement returned
    DBINFO_TEMP=$(grep -E "row[s]* selected"  $DBINFO_TMP_DIR/dbinfo.tmp.$$ | awk '{print $1}')
    if [ "$DBINFO_TEMP" = "no" -o "$DBINFO_TEMP" = "" ] ; then
        DBINFO_RETURNED_ROWS=0
    else
        DBINFO_RETURNED_ROWS=$DBINFO_TEMP
    fi

    # SQL logging if activated :
    LogSql stop $DBINFO_RETURNED_ROWS $DBINFO_TMP_DIR/dbinfo.tmp.$$

    rm -f $DBINFO_TMP_DIR/dbinfo.tmp.$$

    # Turn on PRE tag again
    echo "<PRE>"

    return 0
    }

#---------------------------
# Run specified sql script 
# (This function is really not in use any longer)
# (Still provided in case it's needed later on)
# Input : (1) Script to run
# Output: Output to stdout
#---------------------------
RunSqlScript ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        9*|1*)	export DBINFO_LOGIN="/ as sysdba";;
        *)	export DBINFO_LOGIN="internal";;
    esac

    DBINFO_OUT=$(sqlplus -s "$DBINFO_LOGIN" @$1)
    DBINFO_EC=$?
    [ $DBINFO_EC -gt 0 ] && return $DBINFO_EC

    # OK to return no rows ...
    echo "$DBINFO_OUT" | grep "^no rows selected" && return 0

    # ... else strip output of unwanted lines
    echo "$DBINFO_OUT" | grep -v -E "^$|[0-9] rows selected|PL/SQL procedure successfully"
    return $?
    }

#---------------------------
# Get information about OS
# Input : None
# Output: information to stdout
#---------------------------
GetOsInfo ()
    {
    if [ "$DBINFO_HTML_TABLES" = "YES" -a "$DBINFO_OUTPUT" = "HTML" ] ; then
        GetOsInfo2 | Col2Html "OS Info" NOCOLHEAD left ":"
    else
        GetOsInfo2
    fi
    return $?
    }

GetOsInfo2 ()
    {
    echo "Server name       : $(uname -n)" 
    echo "Server IP         : $DBINFO_IP_ADR"
    echo "Server domain     : $DBINFO_DOMAIN_NAME"
    echo "Server OS         : $(uname -s)"
    if [ "$(uname -s)" = "Linux" ] ; then
        echo "OS Release        : $DBINFO_OS_REL"
        echo "Kernel version    : $DBINFO_OS_VER"
    else
        echo "OS Release           : $DBINFO_OS_REL"
        echo "OS Version           : $DBINFO_OS_VER"
    fi
    echo "32/64 bit OS      : $DBINFO_OSWORD"
    }

#---------------------------
# Get information about HW
# Input : None
# Output: information to stdout
#---------------------------
GetHwInfo ()
    {
    if [ "$DBINFO_HTML_TABLES" = "YES"  -a "$DBINFO_OUTPUT" = "HTML" ] ; then
        GetHwInfo2 | Col2Html "HW Info" NOCOLHEAD left ":"
    else
        GetHwInfo2 
    fi
    return $?
    }

GetHwInfo2 ()
    {
    echo "Server HW type    : $DBINFO_HWTYPE"
    echo "Processor type    : $DBINFO_CPUTYPE"
    echo "Processor family  : $DBINFO_CPUFAMILY"
    echo "Processor count   : $DBINFO_CPUCOUNT"
    echo "32/64 bit HW      : $DBINFO_HWWORD"
    echo "Memory installed  : $DBINFO_MEM_INFO"
    echo "Swap configured   : $DBINFO_SWAP_INFO"
    echo "Storage attached  : $DBINFO_STORAGE_SIZE"
    }

#---------------------------
# Get information about active kernel parameters
# Input : None
# Output: information to stdout
#---------------------------
GetKernelInfo ()
    {
    if [ "$DBINFO_HTML_TABLES" = "YES"  -a "$DBINFO_OUTPUT" = "HTML" ] ; then
        eval $DBINFO_KERNEL_INFO | sed 's/ipc:/Name=Value/' | Col2Html "IPC Values" COLHEAD left  "="
    else
        eval $DBINFO_KERNEL_INFO
    fi
    return $?
    }

#---------------------------
# Get information about filesystems
# Input : None
# Output: information to stdout
#---------------------------
GetDfInfo ()
    {
    if [ "$DBINFO_HTML_TABLES" = "YES"  -a "$DBINFO_OUTPUT" = "HTML" ] ; then
        df | sed 's/Mounted on/Mountpoint/' | Col2Html "Filesystem mount points" COLHEAD dynamic
    else
        df
    fi
    return $?
    }

#---------------------------
# Get information about OS-users
# that can startup, shutdown and 
# admin databases
# Input : None
# Output: information to stdout
#---------------------------
GetOraUsers ()
    {
    # If the oraInst.loc file is present, we've sourced it by now. Check what we've got
    if [ "$inst_group" = "" ] ; then
        echo "Assuming installation group=dba. (No inst_group found in oraInst.loc)"
        inst_group=dba
    fi

    # Users with group membership in dba group
    echo "Database admin-user(s) seems to be:"
    awk -F: -v inst_group=$inst_group ' $1 == inst_group {print "Group "$1,"(gid "$3") : "$4}' /etc/group || return $?


    # Users with default group membership in dba group
    echo "\nPrimary database admin user(s) seems to be:"
    DBINFO_DBAGROUP=$(awk -F: -v inst_group=$inst_group ' $1 == inst_group {print $3}' /etc/group)
    DBINFO_ORAUSERS=$(cut -d: -f1,4 /etc/passwd | grep :$DBINFO_DBAGROUP\$ | cut -d: -f1)

    if [ "$DBINFO_ORAUSERS" = "" ] ; then
        echo "Unable to find any primary user of database(s) using /etc/group and /etc/passwd"
        return 1
    else
        echo "$DBINFO_ORAUSERS"
        return 0
    fi
    }

#---------------------------
# Get information about the current OS-user
# running this script
# Input : None
# Output: information to stdout
#---------------------------
GetOsUserInfo ()
    {
    echo "Username    : $(whoami)"
    echo "Userid      : $(id -u $(whoami))"
    echo "Pri. group  : $(id -g $(whoami))"
    echo "Sec. groups : $(id -G $(whoami))"
    echo "Shell       : $(grep ^$(whoami) /etc/passwd | awk -F: '{print $NF}')"
    echo "Homedir     : $(grep ^$(whoami) /etc/passwd | cut -d: -f6)"
    return $?
    }

#---------------------------
# List the content of the crontab 
# Input :  none
# Output:  crontab for user oracle listed
#---------------------------
GetCrontab ()
    {
    crontab -l 2>/dev/null
    return $?
    }

#---------------------------
# List the environment settings for user
# Note that you'll also get the env's we've set 
# while running this script. 
# Input :  none
# Output:  environment settings
#---------------------------
GetUserenv ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "The user environment controls several aspects of shell and application behaviour."
        AddText info "When running this collector from cron, what is listed here is usually not"
        AddText info "what is listed when run from the commandprompt."
#		AddText info "Crond is rarely able to source the user environment correctly.\n"
    fi
    # Print env settings, Remove DBINFO_* from it, and wrap the text 
    # at specified width to prevent insanely wide browser-windows
    echo "User environment settings are:"
    echo "----------------------------------------------------"
    env | grep -v ^DBINFO_ | fold -w 120
    EC=$?
    return $EC
    }

#---------------------------
# List the active user processes on the server 
# Input :  none
# Output:  environment settings
#---------------------------
GetUserProcs ()
    {
    # Limit process listing  output to 300 chars in width... Better for formatting.
    ps -fu $(whoami) | cut -c1-150
    return $? 
    }

#---------------------------
# Find the location of the oratab
# Input :  OS type (uname -s)
# Output:  None. Location of oratab stored in DBINFO_ORATAB var
#---------------------------
GetOratab ()
    {
    if [ -f $DBINFO_ORATAB ] ; then
        echo "Content of oratab file $DBINFO_ORATAB:\n"
        cat $DBINFO_ORATAB
        return $?
    else
        echo "\nNOT ABLE TO LOCATE AN ORATAB FILE FOR SERVER $(uname -n) !!!"
        echo "Server $(uname -n) has no oratab file" >> $DBINFO_HTML_STATUS
        return 1
    fi
    }

#---------------------------
# Find the location of the oracle inventory
# Input :  None
# Output:  Info to stdout
#---------------------------
GetOraInv ()
    {
    if [ -f /var/opt/oracle/oraInst.loc ] ; then
        DBINFO_ORAINST_FILE="/var/opt/oracle/oraInst.loc"
    elif [ -f /etc/oraInst.loc ] ; then
        DBINFO_ORAINST_FILE="/etc/oraInst.loc"
    else
        echo "\nNOT ABLE TO LOCATE AN oraInst.loc FILE FOR SERVER $(uname -n) !!!"
        echo "Server $(uname -n) has no oraInst.loc file" >> $DBINFO_HTML_STATUS
        DBINFO_ORAINST_FILE=""
        return 1
    fi
    echo "Content of file $DBINFO_ORAINST_FILE :\n"
    cat $DBINFO_ORAINST_FILE
    # Read in file contents for later use
    . $DBINFO_ORAINST_FILE
    }

#---------------------------
# Find the oracle home installations on the server
# Input :  None
# Output:  Info to stdout
#---------------------------	
GetSwInstallations ()
    {
    # Inventory entries
    if [ "$DBINFO_ORAINST_FILE" = "" ] ; then
        OHINV=""
    else
        if [ -d "$inventory_loc" ] ; then
            if [ -r "$inventory_loc/ContentsXML/inventory.xml" ] ; then
                OHINV=$(grep "<HOME NAME=" $inventory_loc/ContentsXML/inventory.xml | sed 's/.*LOC="\(.*\)" TYPE.*/\1/')
                if [ "$OHINV" = "" ] ; then
                    echo "No ORACLE_HOME installations found in inventory.xml\n"
                fi
            else
                echo "\nInventory file $inventory_loc/ContentsXML/inventory.xml is not present !\n"
                echo "Server $(uname -n) doesn't have a valid inventory.xml file" >> $DBINFO_HTML_STATUS
            fi
        else
            echo "\nInventory location in oraInst.loc file $DB_ORAINST_LOC is not present !\n"
            echo "Server $(uname -n) doesn't have a valid inventory location" >> $DBINFO_HTML_STATUS
        fi
    fi
    # Oratab entries
    OHTAB=$(grep -v -E "^$|^#|^\*" $DBINFO_ORATAB | cut -d: -f2)
    if [ "$OHTAB" = "" ] ; then
        echo "No ORACLE_HOME installations found in $DBINFO_ORATAB\n"
    fi
    
    DBINFO_OHALL=$(echo "$OHINV\n$OHTAB" | sort -u | grep -v -E "^$")
    
    RESFILE=$DBINFO_TMP_DIR/dbinfo.$$.sw
    rm -f $RESFILE >/dev/null 2>&1
    echo "$DBINFO_OHALL" | while read OHCK ; do
        # Is it from orainventory or oratab?
        echo "$OHINV" | grep -q "^$OHCK$"
        if [ $? -eq 0 ] ; then
            SOURCE="inventory"
        else
            SOURCE="oratab"
        fi
        
        # Is it valid? Check if the oracle home exists, and that [ $OHCK/bin & $OHCK/lib ] exists
        if [ -d "$OHCK" ] ; then
            if [ -d "$OHCK/bin" -a "$OHCK/lib" ] ; then
                STATUS="OK"
            else
                STATUS="BROKEN"
            fi
        else
            STATUS="MISSING"
        fi 

        # Status OK	: The directory exists, and seems to be in working order
        [ "$STATUS" = "OK" -a "$SOURCE" = "oratab" ] && \
            printf "%-35s : %-10s : %-35s\n" "$OHCK" "$SOURCE" "Possibly OK, but NOT in inventory!" >> $RESFILE
        [ "$STATUS" = "OK" -a "$SOURCE" = "inventory" ] && \
            printf "%-35s : %-10s : %-35s\n" "$OHCK" "$SOURCE" "OK" >> $RESFILE
    
        # Status BROKEN	: The directory exists, but is doesn't seem to be in working order
        #	Cause  	: Deleted or removed, probably
        [ "$STATUS" = "BROKEN" -a "$SOURCE" = "oratab" ] && \
            printf "%-35s : %-10s : %-35s\n" "$OHCK" "$SOURCE" "BROKEN, and NOT in inventory!" >> $RESFILE
        [ "$STATUS" = "BROKEN" -a "$SOURCE" = "inventory" ] && \
            printf "%-35s : %-10s : %-35s\n" "$OHCK" "$SOURCE" "BROKEN (Moved or deleted?)" >> $RESFILE
    
        # Status MISSING: The directory doesn't exists.
        #	Cause  	: Deleted or removed, probably
        [ "$STATUS" = "MISSING" -a "$SOURCE" = "oratab" ] && \
            printf "%-35s : %-10s : %-35s\n" "$OHCK" "$SOURCE" "MISSING and NOT in inventory!" >> $RESFILE
        [ "$STATUS" = "MISSING" -a "$SOURCE" = "inventory" ] && \
            printf "%-35s : %-10s : %-35s\n" "$OHCK" "$SOURCE" "MISSING (Moved or deleted?)" >> $RESFILE
    done
    if [ "$DBINFO_HTML_TABLES" = "YES"  -a "$DBINFO_OUTPUT" = "HTML" ] ; then
        (printf "%-35s : %-10s : %-35s\n" ORACLE_HOME SOURCE STATUS
        cat $RESFILE) | Col2Html "Detected ORACLE HOME directories" COLHEAD dynamic :
    else
        printf "%-35s : %-10s : %-30s\n" ORACLE_HOME SOURCE STATUS
        echo "-------------------------------------------------------------------------------"
        cat $RESFILE
    fi
    rm -f $RESFILE
    return 0
    }

#---------------------------
# Find the location of the cluster config file
# Input :  None
# Output:  None
#---------------------------
GetSrvConfig ()
    {
    if [ -f /var/opt/oracle/srvConfig.loc ] ; then
        echo "Content of file /var/opt/oracle/srvConfig.loc :\n"
        cat /var/opt/oracle/srvConfig.loc
        return $?
    elif [ -f /etc/srvConfig.loc ] ; then
        echo "Content of file /etc/srvConfig.loc :\n"
        cat /etc/srvConfig.loc
        return $?
    else
        echo "No srvConfig.loc can be located for server $(uname -n)"
        return 0
    fi
    }

#---------------------------
# Get and set basic environment for specified sid
# Input :  ORACLE_SID
# Output:  none
#---------------------------
GetSidEnvironment ()
    {
    export ORACLE_SID=$1
    export ORACLE_HOME=$(grep -E "^$1:" $DBINFO_ORATAB | cut -d":" -f2)
    export ORACLE_PATH=$ORACLE_HOME/bin
    export LD_LIBRARY_PATH=$ORACLE_HOME/lib
    export PATH=$ORACLE_PATH:$DBINFO_PATH
    return 0
    }

#---------------------------
# Get basic info for sid 
# Input :  (None - passed by env)
# Output:  
#---------------------------
GetSidInfo ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        7*|8*)		RunSql2Html 999 "v\$database" "select DBID
                        , NAME
                        , to_char(CREATED,'YYYY/MM/DD-HH24:MI:SS') CREATED
                from v\$database;" || return $?;;
        *)		RunSql2Html 999 "gv\$database" "break on INST_ID
                    select INST_ID
                    , DBID
                        , NAME
                        , to_char(CREATED,'YYYY/MM/DD-HH24:MI:SS') CREATED
                        , DATABASE_ROLE
                        , SWITCHOVER_STATUS
                from gv\$database;" || return $?;;
    esac
    echo ""	
    if [ "$DBINFO_RAC_NAME" != "" ] ; then
        AddText std "This instance seems to be part of a Real Application Cluster.\n"
        echo ""
        RunSql2Html 999 "RAC Instances" "column host_name format a30
                        col VERSION form a11
                        break on INST_ID
                        select INST_ID
                            , INSTANCE_NAME INSTANCE
                            , HOST_NAME
                            , VERSION
                            , PARALLEL
                            , DATABASE_STATUS DB_STATUS
                            , STATUS
                            , ARCHIVER
                            , to_char(STARTUP_TIME,'YYYY/MM/DD - HH24:MI:SS') STARTED
                        from gv\$instance 
                        order by INST_ID;" || return $?
        echo ""
    fi
    RunSql2Html 999 "Local Instance" "column host_name format a30
                    col VERSION form a11
                    select INSTANCE_NAME INSTANCE
                        , HOST_NAME
                        , VERSION
                        , PARALLEL
                        , DATABASE_STATUS DB_STATUS
                        , STATUS
                        , ARCHIVER
                        , to_char(STARTUP_TIME,'YYYY/MM/DD - HH24:MI:SS') STARTED
                    from v\$instance;" || return $?

    echo ""
    RunSql2Html 999 "global_name" "col global_name form a40\nselect * from global_name;" || return $?
    echo ""
    RunSql2Html 999 "gv\$version" "break on INST_ID\nselect * from gv\$version order by INST_ID;" || return $?
    echo ""
    RunSql2Html 999 "dba_registry_history" "select * from dba_registry_history;" || return $?
    echo ""
    RunSql2Html 999 "32/64 bit version" "select distinct INST_ID, length(ADDRESS)*4 WORDSIZE from gv\$sql;" || return $?
    echo ""
    RunSql2Html 999 "File count" "break on INST_ID
                select INST_ID, 'Datafiles' filetype, count(*) count from gv\$datafile
                group by INST_ID
                union
                select INST_ID, 'Tempfiles', count(*) from gv\$tempfile
                group by INST_ID
                union
                select INST_ID, 'Controlfiles', count(*) from gv\$controlfile
                group by INST_ID
                union
                select INST_ID, 'Logfiles', count(*) from gv\$logfile
                group by INST_ID;" || return $?
    echo ""
    #  Excluding temp, redo and controlfiles
    RunSql2Html 999 "Instance storage summary" "col MB form 9,999,999\nselect 'Allocated' Space, round(sum(ddf.BYTES)/1024/1024,0) MB 
            from dba_data_files ddf
            union
            select 'Used' , round (sum(ds.BYTES)/1024/1024,0) MB 
            from dba_segments ds;" 
    return $?
    }

#---------------------------
# Get instance license info
# Input : None
# Output: Info on stdout
#---------------------------
GetLicenseInfo ()
    {
    RunSql2Html 999 "gv\$license" "col SESSIONS_MAX form 9,999 heading \"SESS_MAX\"
                col SESSIONS_WARNING form 9,999 heading \"SESS_WARN\"
                col SESSIONS_CURRENT form 9,999 heading \"SESS_CUR\"
                col SESSIONS_HIGHWATER form 9,999 heading \"SESS_HIGHWATER\"
                col USERS_MAX form 9,999 heading \"USERS_MAX\"
                select * from gv\$license
                order by INST_ID;" || return 1

    # Dump out additional license related information for version 10g and upwards.
    case $DBINFO_DB_VERSION_SHORT in
        1*)	RunSql2Html 999 "dba_high_water_mark_statistics" "\
                set lines 150
                col NAME form a20
                col DESCRIPTION form a60
                select
                        NAME
                        ,VERSION
                        ,HIGHWATER
                        ,LAST_VALUE
                        ,DESCRIPTION
                from dba_high_water_mark_statistics
		order by VERSION, NAME;" || return 1
            echo
            RunSql2Html 999 "dba_feature_usage_statistics" "\
                set lines 170
                col NAME form a50 truncate
                col DESCRIPTION form a95 truncate
                select
                        NAME
                        , VERSION
                --      , DETECTED_USAGES
                --      , TOTAL_SAMPLES
                --      , CURRENTLY_USED
                        , FIRST_USAGE_DATE
                --      , LAST_USAGE_DATE
                --      , AUX_COUNT
                --      , FEATURE_INFO
                --      , LAST_SAMPLE_DATE
                --      , LAST_SAMPLE_PERIOD
                --      , SAMPLE_INTERVAL
                        , DESCRIPTION
                from dba_feature_usage_statistics
                where CURRENTLY_USED='TRUE'
                or DETECTED_USAGES > 0
		order by VERSION, NAME;" || return 1;;
    esac
    return 0
    }

#---------------------------
# Get a list of installed adapters
# Input : None
# Output: Info on stdout
#---------------------------
GetInstalledAdapters ()
    {

    if [ -x $ORACLE_HOME/bin/adapters ] ; then
        echo "Output from command \$ORACLE_HOME/bin/adapters"
        echo "---------------------------------------------------------"
        $ORACLE_HOME/bin/adapters
    else
        echo "\nUnable to find \$ORACLE_HOME/bin/adapters."
    fi
    echo
    return 0
    }

#---------------------------
# Get a list of installed products
# Input : None
# Output: Info on stdout
#---------------------------
GetInstalledProducts ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "From version 9i, the most practical way of finding installed products is to start"
        AddText info "up the Oracle Universal Installer, and check the installed products list."
        AddText info "You may also query PRODUCT_COMPONENT_VERSION, GV\$VERSION and GV\$OPTION"
        AddText info "to get an idea of what is installed."
        AddText info "For 8i+ databases, parsing the file \$ORACLE_HOME/inventory/ContentsXML/comps.xml may also help\n"
    fi

        # 8.0.X series has the inspdver executable
        # 8i+ has the unix.rgs file and xml files
        # Check if we're able to list anything, or exit if not
    if [ -f $ORACLE_HOME/orainst/inspdver -o -f $ORACLE_HOME/install/unix.rgs -o -f $ORACLE_HOME/inventory/ContentsXML/comps.xml ]
    then
        :
    else
        echo "\nUnable to find any file with component listings!\n"
        echo "$ORACLE_HOME :  Unable to find any file with component listings!" >> $DBINFO_HTML_STATUS
        return 0
    fi

    # This is for 8.0.x bases.
    if [ -f $ORACLE_HOME/orainst/inspdver ] ; then
        echo "Info from command $ORACLE_HOME/orainst/inspdver:\n"
        $ORACLE_HOME/orainst/inspdver
        return 0
    fi

    # From here and out is for 8i++ bases.
    if [ -f $ORACLE_HOME/install/unix.rgs ] ; then
        echo "Info from file $ORACLE_HOME/install/unix.rgs:"
        echo "----------------------------------------------------------------------"
        cat $ORACLE_HOME/install/unix.rgs
        echo
    fi

    RESFILE=$DBINFO_TMP_DIR/dbinfo.$$.res
    # If we're here, we're on an 8i+ database, so we'll parse comps.xml
    # This one is a bit shaky:
    # 1) Some products are listed twice in the source (bali.help on 9205)
    #    Can be an issue with the oracle installer, bali.help or this script ;-)
    # 2) It hasn't been tested for instances patched more than once 
    #	might give odd results - still not certain
    #
    # Anyway - the awk script builds several arrays storing the component information.
    # At the end, the arrays are parsed, and a readable report is generated.
    # The awk script collects WAY more info than it needs, and some parts of the script can safely be commented out
    #
    if [ -f "$ORACLE_HOME/inventory/ContentsXML/comps.xml" ]  ; then
        # Transform comps.xml into a column-format, containing the info we think we want
        # Send the output to awk, which parses each line and extracts column info and stores it in arrays
        grep -E "^<COMP NAME|^<PATCH|<EXT_NAME>" $ORACLE_HOME/inventory/ContentsXML/comps.xml \
          | sed 's/^<//;s/>$//;s/" /";/g;s/   <EXT_NAME>/;EXT_NAME="/;s.</EXT_NAME.".;s/ NAME=/;/' \
          | awk ' $1 ~ /EXT_NAME/ {print $0};$1 !~ /EXT_NAME/ {printf "%s",$0};' \
          | sed 's/"//g' \
          | awk -F ";"  \
    '
    {
        for (i = 3; i <= NF; i++)
                {
                if ( $i ~ /^VER=/ )             {
                                                gsub("VER=","",$i)
                                                if ( $1 == "COMP" ) ver[$2]=$i
                                                else pver[$2]=$i
                                                }
                if ( $i ~ /^BUILD_NUMBER=/ )    {
                                                gsub("BUILD=","",$i)
                                                build[$2]=$i
                                                }
                if ( $i ~ /^RELEASE=/ )         {
                                                gsub("RELEASE=","",$i)
                                                rel[$2]=$i
                                                }
                if ( $i ~ /^INV_LOC=/ )         {
                                                gsub("INV_LOC=","",$i)
                                                invloc[$2]=$i
                                                }
                if ( $i ~ /^LANGS=/ )           {
                                                gsub("LANGS=","",$i)
                                                langs[$2]=$i
                                                }
                if ( $i ~ /^CLONABLE=/ )        {
                                                gsub("CLONABLE=","",$i)
                                                cloneable[$2]=$i
                                                }
                if ( $i ~ /^XML_INV_LOC=/ )     {
                                                gsub("XML_INV_LOC=","",$i)
                                                xmlinvloc[$2]=$i
                                                }
                if ( $i ~ /^ACT_INST_VER=/ )    {
                                                gsub("ACT_INST_VER=","",$i)
                                                if ( $1 == "COMP" ) aver[$2]=$i
                                                else paver[$2]=$i
                                                }
                if ( $i ~ /^DEINST_VER=/ )      {
                                                gsub("DEINST_VER=","",$i)
                                                dver[$2]=$i
                                                }
                if ( $i ~ /^INSTALL_TIME=/ )    {
                                                gsub("INSTALL_TIME=","",$i)
                                                if ( $1 == "COMP" ) idate[$2]=$i
                                                else pdate[$2]=$i
                                                }
                if ( $i ~ /^INST_LOC=/ )        {
                                                gsub("INST_LOC=","",$i)
                                                instloc[$2]=$i
                                                }
                if ( $i ~ /^EXT_NAME=/ )        {
                                                gsub("EXT_NAME=","",$i)
                                                if ( $1 == "COMP" ) name[$2]=$i
                                                }
                }
    }
    END {
            for (x in name)
                    if ( x in pver )
                            printf ("%-51s = %-14s = %-13s = %-25s = Patched from %s\n",name[x],pver[x],paver[x],pdate[x],ver[x])
                    else
                            printf ("%-51s = %-14s = %-13s = %-25s =  - \n",name[x],ver[x],aver[x],idate[x])
    }' >| $RESFILE

        # Present the component report as either HTML or Plain text
        if [ "$DBINFO_HTML_TABLES" = "YES"  -a "$DBINFO_OUTPUT" = "HTML" ] ; then
            (
            printf "%-33s = %-14s = %-12s = %-27s = %s\n" Component Version "Actual Ver" "Install Time" Comment
            sort $RESFILE
            ) | Col2Html "Product components and versions" COLHEAD left =
        else
            printf "%-33s = %-14s = %-12s = %-27s = %s\n" Component Version "Actual Ver" "Install Time" Comment
            echo "------------------------------------------------------------------------------------------------------------------------"
            sort $RESFILE 
        fi
        rm -f $RESFILE > /dev/null 2>&1
        return 0
    else
        echo "\nComponent source file comps.xml is not present !\n"
        echo "$ORACLE_HOME :  No component xml file found" >> $DBINFO_HTML_STATUS
    fi
    }

#---------------------------
# Get name of the spfile$SID.ora
# (optionally spfile.ora)
# Input : None
# Output: Info on stdout
#---------------------------
GetSpFile ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "When an oracle instance is started, it looks for files containing it's system parameters."
        AddText info "These files control the basic behaviour of an instance, including memory setup, rollback"
        AddText info "segment information and much more."
        AddText info "\nFor pre-9i databases, the default location for the parameterfile (pfile) is "
        AddText info " - \$ORACLE_HOME/dbs/init\$ORACLE_SID.ora"
        AddText info "The init-files may contain references to non-default configuration files."
        AddText info "These files are defined using the IFILE= syntax."

        AddText info "\nAmong the features introduced with Oracle 9i is the optional use of a system parameterfile (spfile)."
        AddText info "The spfile is an initialization file containing a binary version of the traditional init$ORACLE_SID.ora."
        AddText info "An advantage of using the spfile instead of the traditional init-file is the ability to permanently"
        AddText info "change default parameters from within oracle (as opposed to using an editor from the commandline)."
        AddText info "This is especially useful for RAC-installations, where changes can be specified on a per-instance"
        AddText info "basis."

        AddText info "\nAn spfile can be created from an init\$ORACLE_SID.ora file using the statement"
        AddText info "CREATE SPFILE [= '<spfile_name>'] FROM PFILE [= '<pfile_name>'];"
        AddText info "Both spfile_name and pfile_name are optional. The reverse syntax will create a pfile from an spfile."

        AddText info "\nThe 9i-instances look for files in the following order:"
        AddText info " - \$ORACLE_HOME/dbs/spfile\$ORACLE_SID.ora"
        AddText info " - \$ORACLE_HOME/dbs/spfile.ora"
        AddText info " - \$ORACLE_HOME/dbs/init\$ORACLE_SID.ora"
        AddText info "\nFor 9i databases the init\$ORACLE_SID may contain an SPFILE= entry that points to a non-standard"
        AddText info "location and name for an spfile.\n"
    fi

    case $DBINFO_DB_VERSION_SHORT in
        8* )	echo "The oracle spfile-functionality is not available for pre-9i installations."
            return 0;;
    esac

    if [ -f $ORACLE_HOME/dbs/spfile$ORACLE_SID.ora ] ; then
        DBINFO_SPFILE=$ORACLE_HOME/dbs/spfile$ORACLE_SID.ora
    elif [ -f $ORACLE_HOME/dbs/spfile.ora ] ; then
        DBINFO_SPFILE=$ORACLE_HOME/dbs/spfile.ora
    else
        echo "No system parameter file found for instance $ORACLE_SID"
        return 0
    fi

    echo "Database $ORACLE_SID is using system parameter file $DBINFO_SPFILE"

    echo "\nSpfile contents is :"
    echo "----------------------------------------------------"
    strings $DBINFO_SPFILE 
    return $?
    }

#---------------------------
# Get name of and content of initfile
# Input : None
# Output: Info on stdout
#---------------------------
GetPFile ()
    {
    if [ "$DBINFO_SPFILE" != "" ] ; then
        echo "Database $ORACLE_SID is using spfile $DBINFO_SPFILE as primary source for system parameters."
        return 0
    fi

    [ -f $ORACLE_HOME/dbs/init$ORACLE_SID.ora ] && DBINFO_PFILE=$ORACLE_HOME/dbs/init$ORACLE_SID.ora

    if [ "$DBINFO_PFILE" != "" ] ; then
        echo "Content of $ORACLE_SID initialization file $DBINFO_PFILE"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $DBINFO_PFILE 
        return $?
    else
        echo "No oracle initfile found in directory $ORACLE_HOME/dbs"
        return 1
    fi
    }

#---------------------------
# Get name of and content of additional configfile
# .. if any ...
# Input : None
# Output: Info on stdout
#---------------------------
GetIFile ()
    {
    # If we're on 9i using spfile, collect IFILE info from the spfile dump we created earlier on
    # if not, use the initfile under $OH/dbs to find the IFILE name
    if [ "$DBINFO_SPFILE" = "" ] ; then
        DBINFO_IFILE=$(grep -i ifile $DBINFO_PFILE | grep -v "^#" | cut -d "=" -f2 | sed 's/ //g')
    else
        DBINFO_IFILE=$(strings $DBINFO_SPFILE | grep -i ifile | cut -d "=" -f2 | sed 's/ //g')
    fi

    if [ "$DBINFO_IFILE" = "" ] ; then
        echo "No ifile entry found for $ORACLE_SID"
        return 0
    else
        # sometimes, $ORACLE_HOME is refered to as ?, so we change it
        DBINFO_IFILE=$(eval echo $(echo $DBINFO_IFILE | sed 's/\?/$ORACLE_HOME/'))
        echo "\nContent of $ORACLE_SID ifile $DBINFO_IFILE"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $DBINFO_IFILE
        return $?
    fi	
    }

#---------------------------
# Get archiving information
# Input : None
# Output: Info on stdout
#---------------------------
GetArchiveInfo ()
    {
    # NOTE : Might change this to use gv$archive_dest, ++ at a later time

    # Must use srvmgrl for pre-8i for this info.
    case $DBINFO_DB_VERSION_SHORT in
        80* )   DBINFO_OUT=$(echo "connect internal\narchive log list" | svrmgrl | grep -E "log|Automatic|Archive" | sed 's/SVRMGR> //');;
        *)	DBINFO_OUT=$(RunSql 999 "Archive information" "archive log list;");;
    esac

    [ "$DBINFO_OUT" = "" ] && return 1

    echo "$DBINFO_OUT"

    # Are we archiving? And where to?
    DBINFO_ARCHIVE_ENABLED=$(echo "$DBINFO_OUT" | grep "Database log mode" | awk '{print $4}')	
    DBINFO_ARCHIVE_DESTINATION=$(echo "$DBINFO_OUT" | grep "Archive destination" | awk '{print $3}')	
    if [ "$DBINFO_ARCHIVE_DESTINATION" = "USE_DB_RECOVERY_FILE_DEST" ] ; then
	DBINFO_ARCHIVE_DESTINATION=$(RunSql 0 "-" "select VALUE from v\$parameter where upper(NAME) = 'DB_RECOVERY_FILE_DEST';")
    fi

    echo "\nCurrent status of archive destination area:"
    echo "--------------------------------------------"
    if [ "$DBINFO_ARCHIVE_ENABLED" = "No" ] ; then
        echo "Database is not running in archive mode"
    else
        DBINFO_TMP=$(pwd)
        cd $DBINFO_ARCHIVE_DESTINATION
        df .
        cd $DBINFO_TMP
    fi
    return $?
    }

#---------------------------
# Get information for Program Global Area / Process Global Area
# Input : None
# Output: Info on stdout
#---------------------------
GetPgaInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "In version prior to 9i, PGA memory is static. Once memory is allocated to a session,"
        AddText info "it isn't freed until the session terminates. This causes inefficent use of memory, and"
        AddText info "increases the risk of the OS to start swapping memory."
        AddText info "The memory usage is controlled by several init-parameters"
        AddText info "  SORT_AREA_SIZE"
        AddText info "  HASH_AREA_SIZE"
        AddText info "  BITMAP_MERGE_AREA_SIZE "
        AddText info "  CREATE_BITMAP_AREA_SIZE"
        AddText info "  .."
        AddText info ""
        AddText info "In 9i, automatic PGA memory management can be used to dynamically adjust allocated memory"
        AddText info "for a given session."
        AddText info "To enable this feature, these init-parameters must be set:"
        AddText info "   WORKAREA_SIZE_POLICY=AUTO"
        AddText info "   PGA_AGGREGATE_TARGET=(Max PGA available to oracle)"
        AddText info "Setting these causes Oracle to disregard any set  \*_AREA_SIZE parameters"
        AddText info ""
        AddText info "Setting the parameter STATISTICS_LEVEL to TYPICAL or ALL in 9iR2 enables"
        AddText info "oracle to give advice on PGA_AGGREGATE_TARGET using the view V\$PGA_TARGET_ADVICE\n"
    fi
    case $DBINFO_DB_VERSION_SHORT in
        8*)	AddText std "Automatic PGA memory management is not available for this instance.\n"
            RunSql2Html 999 "Process memory allocation" "break on INST_ID
                                col NAME form a50
                                col INST_ID form 99
                                col VALUE form a30	
                                select INST_ID, NAME, VALUE 
                                from gv\$parameter
                                where NAME like '%_area_size'
                                order by INST_ID;" || return $?;;

        90*)	RunSql2Html 999 "Automatic PGA settings" "break on INST_ID
                        col NAME form a50
                        col VALUE form a30
                        select INST_ID, NAME, VALUE 
                        from gv\$parameter
                        where NAME in ('workarea_size_policy','pga_aggregate_target')
                        order by INST_ID;"
            echo ""
            RunSql2Html 999 "PGA Statistics" "break on INST_ID
                            col VALUE form 999,999,999,999,999
                            select * from gv\$pgastat order by INST_ID;"
            AddText std "\nNo PGA Advice is available for this instance\n";;

        *)	RunSql2Html 999 "Automatic PGA settings" "break on INST_ID
                        col NAME form a50
                        col VALUE form a30
                        select INST_ID, NAME, VALUE 
                        from gv\$parameter
                        where NAME 
                           in ('workarea_size_policy','pga_aggregate_target','statistics_level')
                        order by INST_ID;"
            echo ""
            RunSql2Html 999 "PGA Statistics" "break on INST_ID
                            col VALUE form 999,999,999,999,999
                            select * from gv\$pgastat order by INST_ID;"
            AddText std "\nNote the cache hit and over allocation count.\n"

            RunSql2Html 999 "PGA Advice" "break on INST_ID
                col ESTD_OVERALLOC_COUNT form 99,999,999,999,999
                select INST_ID, round(PGA_TARGET_FOR_ESTIMATE/1024/1024,0) ESTIMATE_MB
                    , PGA_TARGET_FACTOR
                --      , ESTD_EXTRA_BYTES_RW
                    , ESTD_PGA_CACHE_HIT_PERCENTAGE HIT_RATE
                    , ESTD_OVERALLOC_COUNT
                --      , ADVICE_STATUS
                from gv\$pga_target_advice
                where ADVICE_STATUS='ON'
                order by INST_ID, round(PGA_TARGET_FOR_ESTIMATE/1024/1024,0);"
            AddText std "\nAim for ESTD_OVERALLOC_COUNT = 0, and a high HIT_RATE.\n";;
    esac
    return 0	
    }

#---------------------------
# Get general information for System Global Area
# Input : None
# Output: Info on stdout
#---------------------------
GetSgaInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "\nThe System Global Area (SGA) is the memory area used by the oracle instance for"
        AddText info "things like caching, logging, sql parsing and execution." 
        AddText info "The SGA is split into several memory areas, including:"
        AddText info " - Shared pool"
        AddText info "  - Large pool"
        AddText info "  - Java pool"
        AddText info " - Buffer cache"
        AddText info " - Redo log buffer"
        AddText info " - Dictionary cache"
        AddText info ""
        AddText info "In 9i several of these memory areas can be resized dynamically, within the upper limit"
        AddText info "set by the SGA_MAX_SIZE parameter. If not set, SGA_MAX_SIZE defaults to the sum of"
        AddText info "configured SGA memory areas.\n"
    fi

    RunSql2Html 999 "gv\$sga" "break on INST_ID
            select INST_ID,' Total System Global Area' NAME, sum(value) VALUE
            from gv\$sga
            group by INST_ID
            union
            select INST_ID, NAME, VALUE  
            from gv\$sga
            order by INST_ID, VALUE desc;" || return $?
    }

#---------------------------
# Get information for SGA / Shared Pool
# Input : None
# Output: Info on stdout
#---------------------------
GetSharedPoolInfo ()
    {
    RunSql2Html 999 "Configured pool sizes" "col VALUE form a25
        col NAME form a25
        break on INST_ID
        select INST_ID, NAME, VALUE 
        from gv\$parameter
        where NAME in ('shared_pool_size','shared_pool_reserved_size','large_pool_size','java_pool_size')
        order by INST_ID, NAME;" || return $?
    echo ""
    RunSql2Html 999 "gv\$sgastat" "break on INST_ID
            select * 
            from gv\$sgastat
            order by INST_ID, POOL, NAME;" || return $?
    }

#---------------------------
# Get information for SGA / Buffer Cache
# Input : None
# Output: Info on stdout
#---------------------------
GetBufferCacheInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "\nThe database buffer cache is used to minimize physical I/O operations in the database."
        AddText info "In systems prior to 9i, the cache size was calculated using the parameters DB_BLOCK_SIZE"
        AddText info "and DB_BLOCK_BUFFERS."
        AddText info "Oracle 9i introduces an alternative method of setting the size using DB_CACHE_SIZE."
        AddText info "For non-default block-sizes in a database, the parameters DB_(x)K_CACHE_SIZE can be used."
        AddText info "9i also features builtin cache size advice using the view V\$DB_CACHE_ADVICE. To enable"
        AddText info "this functionality, set DB_CACHE_ADVICE=ON for 9i. For 9iR2 and on, use the parameter"
        AddText info "STATISTICS_LEVEL.\n" 
    fi
    RunSql2Html 999 "DB Cache parameters" "col NAME form a25
                    col VALUE form a25
                    break on INST_ID
                    select INST_ID, NAME, VALUE 
                    from gv\$parameter
                    where NAME 
                        in ('db_block_size','db_block_buffers','db_cache_advice','statistics_level')
                    or name like '%cache_size'
                    or name like 'buffer_pool%'
                    order by INST_ID, name;" || return $?

    # Still need a good way of computing Hit Rate for buffer cache. These differ too much in result
    AddText std "\nBefore interpreting Buffer Cache Hit Ratio values, be aware that there are"
    AddText std "different ways of computing them on different versions of Oracle."
    AddText std "Don't take numbers produced here too seriously."
    echo ""

    # Thw only differences in the 90|91 and the 92|10 sections is the SIZE_FACTOR in the 2. sql
    case $DBINFO_DB_VERSION_SHORT in
        90*|91*) RunSql2Html 999 "Buffer Cache Hit Ratio" "break on INST_ID
            col HIT_RATIO form 999.99
            select INST_ID
            , BLOCK_SIZE
            , NAME
            , round((1-(PHYSICAL_READS/(CONSISTENT_GETS + DB_BLOCK_GETS )))*100,2)  HIT_RATIO
            from gv\$buffer_pool_statistics
            where ( CONSISTENT_GETS + DB_BLOCK_GETS ) !=0
            order by INST_ID, BLOCK_SIZE;" || return $?
            echo ""
            RunSql2Html 999 "gv\$db_cache_advice" "break on INST_ID
            select INST_ID
                , NAME
                , BLOCK_SIZE
                , SIZE_FOR_ESTIMATE
                , ESTD_PHYSICAL_READ_FACTOR
                , ESTD_PHYSICAL_READS 
            from gv\$db_cache_advice
            where ADVICE_STATUS='ON'
            order by INST_ID, BLOCK_SIZE, SIZE_FOR_ESTIMATE;" || return $?;;
        92*|1*) RunSql2Html 999 "Buffer Cache Hit Ratio" "Break on INST_ID
            col HIT_RATIO form 999.99
            select INST_ID
            , BLOCK_SIZE
            , NAME
            , round((1-(PHYSICAL_READS/(CONSISTENT_GETS + DB_BLOCK_GETS )))*100,2)  HIT_RATIO
            from gv\$buffer_pool_statistics
            where ( CONSISTENT_GETS + DB_BLOCK_GETS ) !=0
            order by INST_ID, BLOCK_SIZE;" || return $?
            echo ""
            RunSql2Html 999 "gv\$db_cache_advice" "break on INST_ID
            select INST_ID
                , NAME
                , BLOCK_SIZE
                , SIZE_FOR_ESTIMATE
                , SIZE_FACTOR
                , ESTD_PHYSICAL_READ_FACTOR
                , ESTD_PHYSICAL_READS
--		, ADVICE_STATUS
            from gv\$db_cache_advice
            where ADVICE_STATUS='ON'
            order by INST_ID, BLOCK_SIZE, SIZE_FOR_ESTIMATE;" || return $?;;
        *)  	RunSql2Html 999 "Buffer Cache Hit Ratio" "col HIT_RATIO form 999.99
                select cur.INST_ID
                , 100*(cur.VALUE + con.VALUE - phys.VALUE)/(cur.VALUE + con.VALUE)  HIT_RATIO
                from gv\$sysstat cur
                    ,gv\$sysstat con
                    ,gv\$sysstat phys
                    ,gv\$statname ncu
                    ,gv\$statname nco
                    ,gv\$statname nph
                where cur.STATISTIC# = ncu.STATISTIC#
                    and ncu.INST_ID=cur.INST_ID
                    and con.INST_ID=cur.INST_ID
                    and nco.INST_ID=cur.INST_ID
                    and nph.INST_ID=cur.INST_ID
                    and phys.INST_ID=cur.INST_ID
                    and ncu.NAME = 'db block gets'
                    and con.STATISTIC# = nco.statistic#
                    and nco.NAME = 'consistent gets'
                    and phys.STATISTIC# = nph.statistic#
                    and nph.NAME = 'physical reads';" || return $?;;
    esac
    return 0
    }

#---------------------------
# Get information for SGA / Misc info
# Input : None
# Output: Info on stdout
#---------------------------
GetSgaMiscInfo ()
    {
    RunSql2Html 999 "Library Cache Information" "break on INST_ID
            col GHR form 999.99 heading \"GET HIT %\"
            col PHR form 999.99 heading \"PIN HIT %\"
            select INST_ID
                    , NAMESPACE NAME
                    , GETS
                    , GETHITS
                    , GETHITRATIO*100 GHR
                    , PINS
                    , PINHITS
                    , PINHITRATIO*100 PHR
                    , RELOADS
                    , INVALIDATIONS
            from gv\$librarycache
            order by INST_ID, NAMESPACE;" || return $?

    AddText std "\nPIN HIT % Should be close to 100%. Consider increasing shared pool if not."
    echo ""

    RunSql2Html 999 "Dictionary Cache Information" "break on INST_ID
            col HR form 999.99 heading \"HIT %\"
            select INST_ID
                , PARAMETER
                , sum(GETS)
                , sum(GETMISSES)
                , 100*sum(GETS - GETMISSES) / sum(GETS) HR
                , sum(MODIFICATIONS) UPDATES
            from GV\$ROWCACHE
            where GETS > 0
            group by INST_ID, PARAMETER;" || return $?

    AddText std "\nConsider increasing shared pool if HIT % is low, or if there is latch contention on Row Cache Objects"
    AddText std "In general, extended use of locally managed tablespaces will decrease row cache locks."
    echo ""

    RunSql2Html 999 "log_buffer" "break on INST_ID
            select INST_ID
            , 'Redo log space request' REQUEST 
            , VALUE  
            from gv\$sysstat
                        where NAME = 'redo log space requests'
                        order by INST_ID;" || return $?

    AddText std "\nConsider increasing LOG_BUFFER if a high value occurs here"
    return 0
    }
            
#---------------------------
# Get information on what options
# the database supports ... partitions, transportable tblspcs ...
# Input : None
# Output: Info on stdout
#---------------------------
GetOptionInfo ()
    {
    RunSql2Html 999 "PRODUCT_COMPONENT_VERSION" "col PRODUCT form a60
        col VERSION form a10
        col STATUS form a25
        select * 
        from product_component_version;" || return $?
    echo "\n"
    RunSql2Html 999 "gv\$option" "col VALUE form a15
        break on INST_ID
        select INST_ID, PARAMETER, VALUE 
        from gv\$option 
        order by INST_ID;"
    return $?
    }

#---------------------------
# Get non-default database parameters
# Input : None
# Output: Info on stdout
#---------------------------
GetParameters ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "This query shows the active database parameters, excluding"
        AddText info "the entries that have default values."
        AddText info "For a complete list, query the view gv\$parameter.\n"
    fi
    RunSql2Html 999 "Non-default gv\$parameter entries" "col name form a35
            col VALUE form a80
            set linesize 2000
            break on INST_ID
            select INST_ID, NAME, VALUE 
            from gv\$parameter
            where ISDEFAULT='FALSE'
            order by INST_ID, NAME;" || return $?
    return $?
    }

#---------------------------
# Get modified database parameters
# That is - parameters changed after database startup
# Input : None
# Output: Info on stdout
#---------------------------
GetAdjParameters ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "This query shows the database parameters that have been"
        AddText info "changed since system startup.\n"
    fi
    RunSql2Html 999 "Modified gv\$parameter entires" "col name form a35
            col VALUE form a80
            set linesize 2000
            break on INST_ID
            select INST_ID, NAME, VALUE 
            from gv\$parameter
            where ISMODIFIED = 'TRUE'
            order by INST_ID, NAME;" || return $?
    return $?
    }

#---------------------------
# Get only the security-related database parameters
# Input : None
# Output: Info on stdout
#---------------------------
GetSecParameters ()
    {
    RunSql2Html 9999 "Security related parameters" "set linesize 2000
        col PARAMETER form a12
        select NAME, VALUE "PARAMETER"
        from   sys.v_\$parameter 
        where  NAME in (
		'remote_login_passwordfile'
		, 'remote_os_authent' 
           	, 'os_authent_prefix'
		, 'dblink_encrypt_login'
		, 'audit_trail'
		, 'transaction_auditing'
		);" 
    return $?
    }

#---------------------------
# Get info from the running listener
# * The 'Shared' function list out files found under the common directories (etc and var) 
# * The other one lists out for selected $ORACLE_HOME if not found in the shared dirs.
# Input : None 
# Output: Info on stdout
#---------------------------
GetListenerSecurityShared ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Standard setup of the oracle listener doesn't enable any form of security when it comes to online"
        AddText info "listener administration (startup, shutdown and configuration changes)."
        AddText info "This enables _any_ computer that has the listener binary (lsnrctl) installed to remotely shutdown"
        AddText info "the database listener."
        AddText info "You can set a password for your listener by using the 'set password' command from within"
        AddText info "lsnrctl, but be aware that you may have to alter any automated listener statup/shutdown scripts"
        AddText info "afterwards.\n"
    fi
    if [ "$DBINFO_LISTENER_SHARED" = "" ] ; then
        echo "No shared listener configuration file is used."
        return 0
    else
        DBINFO_LISTENERS=$(cat $DBINFO_LISTENER_SHARED | awk ' $1 ~ /SID_LIST_|sid_list/ {print $1}' | cut -c10- | sed 's/=//')
        if [ "$DBINFO_LISTENERS" = "" ] ; then
                        AddText warning "No configured listeners found in file $DBINFO_LISTENER_SHARED."
                        return 0
                fi
        for i in $DBINFO_LISTENERS ; do
            cat $DBINFO_LISTENER_SHARED | grep -i PASSWORDS_$i | grep -q -v -E "^#"
            if [ $? -eq 0 ] ; then
                echo "Shared listener $i : OK"
            else
                echo "Shared listener $i has no password set" >> $DBINFO_HTML_STATUS
                AddText warning "Shared listener $i : NO PASSWORD SET"
            fi
        done
    fi
    }

GetListenerSecurity ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Standard setup of the oracle listener doesn't enable any form of security when it comes to online"
        AddText info "listener administration (startup, shutdown and configuration changes)."
        AddText info "This enables _any_ computer that has the listener binary (lsnrctl) installed to remotely shutdown"
        AddText info "the database listener."
        AddText info "You can set a password for your listener by using the 'set password' command from within"
        AddText info "lsnrctl, but be aware that you may have to alter any automated listener statup/shutdown scripts"
        AddText info "afterwards.\n"
    fi
    # Use the listener location found earlier on to determine wether security has been enabled.
    if [ "$DBINFO_LISTENER_SHARED" != "" ] ; then
        echo "Oracle home ($ORACLE_HOME) seems to be using a shared listener config file,"
        echo "or it's configured to use \$TNS_ADMIN for configuration files."
        return $?
    else
        if [ -f "$ORACLE_HOME/network/admin/listener.ora" ] ; then
            DBINFO_LISTENERS=$(cat $ORACLE_HOME/network/admin/listener.ora | awk ' $1 ~ /SID_LIST_|sid_list/ {print $1}' | cut -c10- | sed 's/=//')
            if [ "$DBINFO_LISTENERS" = "" ] ; then
                echo "No configured listeners found."
                return 	0
            fi
            for i in $DBINFO_LISTENERS ; do
                cat $ORACLE_HOME/network/admin/listener.ora | grep -i PASSWORDS_$i | grep -q -v -E "^#"
                if [ $? -eq 0 ] ; then
                    echo "$ORACLE_HOME : Listener $i : OK"
                else
                    echo "$ORACLE_HOME : Listener $i has no password set" >> $DBINFO_HTML_STATUS
                    AddText warning "$ORACLE_HOME : Listener $i : NO PASSWORD SET"
                fi
            done
        fi
    fi
    return 0
    }

#---------------------------
# Get configuration for oracle listener
# * The 'Shared' function list out files found under the common directories (etc and var) 
# * The other one lists out for selected $ORACLE_HOME if not found in the shared dirs.
# Input : None 
# Output: Info on stdout
# NOTE : Oracle search for config files in this order:
#	$TNS_ADMIN/tnsnames.ora (We dont' search this one - too many ways to set it ...)
#	/etc/tnsnames.ora
#	/var/opt/oracle/tnsnames.ora
#	$ORACLE_HOME/network/admin/tnsnames.ora
#---------------------------
GetListenerConfigShared ()
    {
    DBINFO_LISTENER_SHARED=""
    if [ -f /etc/listener.ora ] ; then
        DBINFO_LISTENER_SHARED=/etc/listener.ora
    elif [ -f /var/opt/oracle/listener.ora ] ; then
        DBINFO_LISTENER_SHARED=/var/opt/oracle/listener.ora
    fi
    if [ "$DBINFO_LISTENER_SHARED" = "" ] ; then
        echo "No shared listener configuration file is used"
        return 0
    else
        echo  "Content of shared listener configuration file $DBINFO_LISTENER_SHARED:"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $DBINFO_LISTENER_SHARED
        return $?
    fi
    }

GetListenerConfig ()
    {
    if [ "$DBINFO_LISTENER_SHARED" != "" ] ; then
            echo "Oracle home ($ORACLE_HOME) seems to be using a shared listener config file,"
            echo "or it's configured to use \$TNS_ADMIN for configuration files."
            return $?
    fi
    if [ -f $ORACLE_HOME/network/admin/listener.ora ] ; then
        echo  "Content of listener configuration file $ORACLE_HOME/network/admin/listener.ora:"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $ORACLE_HOME/network/admin/listener.ora
        return $?
    else
        echo "$ORACLE_HOME : No usable listener.ora file found" >> $DBINFO_HTML_STATUS
        AddText warning "$ORACLE_HOME : No usable listener.ora file found"
        return 0
    fi
    return 0
    }

#---------------------------
# Get configuration for SQL*Net
# * The 'Shared' function list out files found under the common directories (etc and var)
# * The other one lists out for selected $ORACLE_HOME if not found in the shared dirs.
# Input : None 
# Output: Info on stdout
# NOTE : Oracle search for config files in this order:
#	$TNS_ADMIN/tnsnames.ora (We dont' search this one - too many ways to set it ...)
#	/etc/tnsnames.ora
#	/var/opt/oracle/tnsnames.ora
#	$ORACLE_HOME/network/admin/tnsnames.ora
#---------------------------
GetSqlnetConfigShared  ()
    {
    DBINFO_SQLNET_SHARED=""
    if [ -f /etc/sqlnet.ora ] ; then
        DBINFO_SQLNET_SHARED=/etc/sqlnet.ora
    elif [ -f /var/opt/oracle/sqlnet.ora ] ; then
        DBINFO_SQLNET_SHARED=/var/opt/oracle/sqlnet.ora
    fi
    if [ "$DBINFO_SQLNET_SHARED" = "" ] ; then
        echo "No shared sqlnet configuration file is used"
        return 0
    else
        echo  "Content of shared sqlnet configuration file $DBINFO_SQLNET_SHARED:"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $DBINFO_SQLNET_SHARED
        return $?
    fi
    }

GetSqlnetConfig ()
    {
    if [ "$DBINFO_SQLNET_SHARED" != "" ] ; then
            echo "Oracle home ($ORACLE_HOME) seems to be using a shared sqlnet config file,"
            echo "or it's configured to use \$TNS_ADMIN for configuration files."
            return $?
    fi
    if [ -f $ORACLE_HOME/network/admin/sqlnet.ora ] ; then
        echo  "Content of sqlnet configuration file $ORACLE_HOME/network/admin/sqlnet.ora:"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $ORACLE_HOME/network/admin/sqlnet.ora
        return $?
    else
        echo "$ORACLE_HOME : No usable sqlnet.ora file found" >> $DBINFO_HTML_STATUS
        AddText warning "$ORACLE_HOME : No usable sqlnet.ora file found"
        return 0
    fi
    return 0
    }

#---------------------------
# Get content of tnsnames file
# * The 'Shared' function list out files found under the common directories (etc and var)
# * The other one lists out for selected $ORACLE_HOME if not found in the shared dirs.
# Input : None 
# Output: Info on stdout
# NOTE : Oracle search for config files in this order:
#	$TNS_ADMIN/tnsnames.ora (We dont' search this one - too many ways to set it ...)
#	/etc/tnsnames.ora
#	/var/opt/oracle/tnsnames.ora
#	$ORACLE_HOME/network/admin/tnsnames.ora
#---------------------------
GetTnsnamesConfigShared ()
    {
    DBINFO_TNSNAMES_SHARED=""
    if [ -f /etc/tnsnames.ora ] ; then
        DBINFO_TNSNAMES_SHARED=/etc/tnsnames.ora
    elif [ -f /var/opt/oracle/tnsnames.ora ] ; then
        DBINFO_TNSNAMES_SHARED=/var/opt/oracle/tnsnames.ora
    fi
    if [ "$DBINFO_TNSNAMES_SHARED" = "" ] ; then
        echo "No shared tnsnames configuration file is used"
        return 0
    else
        echo  "Content of shared tnsnames configuration file $DBINFO_TNSNAMES_SHARED:"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $DBINFO_TNSNAMES_SHARED
        return $?
    fi
    }

GetTnsnamesConfig ()
    {
    if [ "$DBINFO_TNSNAMES_SHARED" != "" ] ; then
            echo "Oracle home ($ORACLE_HOME) seems to be using a shared tnsnames config file,"
            echo "or it's configured to use \$TNS_ADMIN for configuration files."
            return $?
    fi
    if [ -f $ORACLE_HOME/network/admin/tnsnames.ora ] ; then
        echo  "Content of tnsnames configuration file $ORACLE_HOME/network/admin/tnsnames.ora:"
        echo "(Comments and empty lines removed)\n----------------------------------------------------"
        grep -v -E "^$|^#" $ORACLE_HOME/network/admin/tnsnames.ora
        return $?
    else
        echo "$ORACLE_HOME : No usable tnsnames.ora file found" >> $DBINFO_HTML_STATUS
        AddText warning "$ORACLE_HOME : No usable tnsnames.ora file found"
        return 0
    fi
    return 0
    }

#---------------------------
# Get last lines of alertlog
# Input : None
# Output: Info on stdout
#---------------------------
GetAlertlog ()
    {
    # If we're on 11g, calll adrci to get the info we need
    if [ -x $ORACLE_HOME/bin/adrci ] ; then
	echo "Last lines from database alertlog for $ORACLE_SID"
	echo "------------------------------------------------------------"
	echo show alert -tail 100 | adrci
	return $?
    fi

    # Try the other options
    if [ "$DBINFO_SPFILE" = "" ] ; then
        DBINFO_BDUMP=$(grep -i ^background_dump_dest $ORACLE_HOME/dbs/init$ORACLE_SID.ora | cut -d= -f2)
    else
        DBINFO_BDUMP=$(strings $DBINFO_SPFILE | grep background_dump_dest | cut -d= -f2 | sed "s/'//g")
    fi
    if [ -e $DBINFO_BDUMP/alert_$ORACLE_SID.log ] ; then
        echo "Last lines from database alertlog $DBINFO_BDUMP/alert_$ORACLE_SID.log"
        echo "------------------------------------------------------------"
        tail -100 $DBINFO_BDUMP/alert_$ORACLE_SID.log
        return $?
    else
        echo Unable to find alertlog file for database $ORACLE_SID in directory $DBINFO_BDUMP
        return $?
    fi
    }

#---------------------------
# Find out wether the databse $ORACLE_SID is up
# or not.
# Input : None
# Output: return code
#---------------------------
CheckDbStatus ()
    {
    ps -ef | grep -v grep | grep "smon_$ORACLE_SID$" > /dev/null 2>&1
    return $?
    }

#---------------------------
# Find the active NLS parameters 
# for the database
# Input : None
# Output: return code
#---------------------------
GetNlsParameters ()
    {
    RunSql2Html 999 "nls_database_parameters" "select * from nls_database_parameters;" 
    return $?
    }

#---------------------------
# Locate database controlfiles
# Get a dump of tracefile
# Input : None
# Output: return code
#---------------------------
GetControlFiles ()
    {
    RunSql2Html 999 "gv\$controlfile" "col NAME form a60
        break on INST_ID
        select INST_ID, DECODE(STATUS, null, '-',STATUS) STATUS , NAME 
	from gv\$controlfile
        order by INST_ID;" || return $?

    echo "\nContent of local controlfile dump:\n------------------------------------------------------------"
    DBINFO_UDUMP_DEST=$(RunSql 0 - "set feedback off\nselect VALUE from v\$parameter where NAME = 'user_dump_dest';")
    if [ "$DBINFO_UDUMP_DEST" = "" ] ; then
        echo "Unable to find udump destination"
        return 1
    fi

    RunSql 0 - "alter database backup controlfile to trace;" > /dev/null || return $?
    # This one fails if you have too many trace files in your udump directory
    DBINFO_TRACEFILE=$(ls -1rt $DBINFO_UDUMP_DEST/*.trc 2>/dev/null | tail -1)
    if [ "$DBINFO_TRACEFILE" = "" ] ; then
        echo "Unable to find a tracefile under udump destination" 
        return 1
    fi
    # Pause before reading the file - give oracle time to write it to disk ...
    sleep 5
    cat $DBINFO_TRACEFILE
    return $?
    }

#---------------------------
# Get information about database
# redolog files
# Input : None
# Output: return code
#---------------------------
GetRedologFiles ()
    {
    RunSql2Html 999 "gv\$logfile" "col MEMBER form a60
        break on INST_ID
        select a.INST_ID, MEMBER, a.GROUP# LOG_GROUP, round(b.BYTES/1024/1024,0) MB 
        from gv\$logfile a
		,gv\$log b 
        where a.GROUP#=b.GROUP# 
        and a.INST_ID=b.INST_ID
        order by INST_ID;" || return $?
    echo ""
    RunSql2Html 999 "gv\$log" "break on INST_ID
	col FIRST_CHANGE# form 99999999999999999
	select * 
	from gv\$log 
	order by INST_ID;" 
    return $?
    }

#---------------------------
# Get information about all datafiles 
# in the database
# Input : None
# Output: return code
#---------------------------
GetDatafileInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "To simplify maintenance and backup/recovery scenarios, datafile placement should be planned well." 
        AddText info "Place them in dedicated directories, and if possible, place the directories on filesystems"
        AddText info "that are only used by oracle."
        AddText info "Try to balance I/O over all the available filesystems.\n"
    fi
    RunSql2Html 9999 "Database datafiles" "set lines 300
        col TABLESPACE_NAME form a20 truncate heading TABLESPACE
        col FILE_ID form 9999 HEADING \"#ID\"
        col FILE_NAME form a60 truncate
        col AUTOEXT form a8 heading AUTO
        col MB form 999,999
        break on TABLESPACE_NAME
        select TABLESPACE_NAME
		, FILE_ID
		, FILE_NAME
		, round(BYTES/1024/1024,0) MB
		,round(MAXBYTES/1024/1024,0) MAX
		, AUTOEXTENSIBLE AUTOEXT
		, STATUS
        from dba_data_files
        order by TABLESPACE_NAME;"
    return $?
    }

#---------------------------
# Get information about datafiles
# that have autoextend enabled
# Input : None
# Output: return code
#---------------------------
GetDatafileAutoextend ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Autoextending datafiles will increase their size when they need to allocate extra storage."
        AddText info "The positive benefit of this is that the DBA will not have to pay as close attention to the"
        AddText info "free space in the tablespaces,"
        AddText info "The downside is that the system runs the risk of filling an entire filesystems without anybody noticing."
        AddText info "For some filesystem types, this is fatal."
        AddText info "\nData corruption may occur if the datafile is in some way extended beyond the upper filesize-limit"
        AddText info "oracle currently imposes (4194303 * size of db_block_size). There are several reported bugs"
        AddText info "concerning this.\n"
    fi
    RunSql2Html 9999 "Autoextending datafiles" "set lines 300 
        col TABLESPACE_NAME form a25 heading TABLESPACE
        col FILE_ID form 9999
        col FILE_NAME form a50
        col AUTO form a5
        col MB form 999,999
        col MAXMB form 999,999
        break on TABLESPACE_NAME
	select TABLESPACE_NAME
		, FILE_ID
		, FILE_NAME
		, round(BYTES/1024/1024,0) MB
		, round(MAXBYTES/1024/1024,0) MAXMB
		,  AUTOEXTENSIBLE AUTO
		, STATUS
                from dba_data_files
                where AUTOEXTENSIBLE='YES'
        order by TABLESPACE_NAME;"
    return $?
    }

#---------------------------
# Get information about datafiles
# that are not listed as AVAILABLE
# Input : None
# Output: return code
#---------------------------
GetDatafileAvailibility ()
    {
    RunSql2Html 9999 "Datafiles not listed available" "select FILE_NAME, STATUS
            from dba_data_files
            where STATUS != 'AVAILABLE';" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS unavailable datafiles" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Get information about current 
# IO for datafiles in the database
# Input : None
# Output: return code
#---------------------------
GetFileIO ()
    {
    RunSql2Html 9999 "Most active datafiles" "set lines 300
        col PHYRDS form 99,999,999,999
        col PHYWRTS form 99,999,999,999
        col TOTAL form 99,999,999,999
        col MB form 999,999
        select * from (
            	select substr(a.FILE#,1,4) \"#\"
		, substr(a.NAME,1,60) "NAME"
            	, a.STATUS
            	, round(a.BYTES/1024/1024,0) MB
            	, b.PHYRDS
            	, b.PHYWRTS
            	, b.PHYRDS+b.PHYWRTS TOTAL
            from v\$datafile a
		, v\$filestat b
            where a.FILE# = b.FILE#
            order by TOTAL desc
            )
        where rownum < 31;"
    return $?
    }

#---------------------------
# Get information about possible datafile corruption
# Input : None
# Output: return code
#---------------------------
GetFileCorruption ()
    {
    case $DBINFO_DB_VERSION_SHORT in
    	8)	echo "Version prior to 9i doesn't have the v\$database_block_corruption view.";;
	*)	RunSql2Html 999 "v\$database_block_corruption" "\
        		select * from v\$database_block_corruption;";;
    esac
    }

#---------------------------
# Get summary of information about tablespaces
# in the database
# Input : None
# Output: return code
#---------------------------
GetTablespaceInfo ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        8*)     RunSql2Html 9999 "Tablespace overview" "column TOT_SIZE format 999,999,999,999
     		column TOT_FREE format 999,999,999,999
     		column PCT format 999 Heading \"%USED\"
     		column FRAGS format 9,999,999
     		col TABLESPACE form a25
     		col BLOCK_SIZE form 999999
     		col STATUS form a15
     		col CONTENTS form a12
     		col EXTENT_MANAGEMENT form a12 heading \"EXTMAN\"
     		col ALLOCATION_TYPE form a12 heading \"ALLOCTYPE\"
     		col SEGMENT_SPACE_MANAGEMENT form a12 heading \"SEGMAN\"
     		set echo off
     		select aa.TABLESPACE
			, STATUS
			, CONTENTS
			, EXTENT_MANAGEMENT
			, ALLOCATION_TYPE
			, TOT_SIZE
			, TOT_FREE
			, PCT
			, FRAGS
        	from (
                	select substr(a.TABLESPACE_NAME,1,25) TABLESPACE,
                	sum(a.TOTS) TOT_SIZE,
                	sum(a.SUMB) TOT_FREE,
                	round(100-sum(a.SUMB)*100/sum(a.TOTS),1) PCT,
                	sum(a.LARGEST) MAX_FREE,sum(a.CHUNKS) FRAGS,
                	TMP
                	from (select TABLESPACE_NAME,0 TOTS,sum(BYTES) SUMB, max(BYTES) LARGEST,count(*) CHUNKS, null TMP
                       			from dba_free_space a
                       			group by TABLESPACE_NAME
                		union
                       			select TABLESPACE_NAME,sum(BYTES) TOTS,0,0,0, null TMP 
					from dba_data_files
                       			group by TABLESPACE_NAME
                		union
                       			select TABLESPACE_NAME, sum(BYTES) TOTS,0,0,0, '*' TMP 
					from dba_temp_files
                       			group by TABLESPACE_NAME
                		union
                       			select TABLESPACE_NAME,0 TOTS, sum(BYTES_CACHED-BYTES_USED) SUMB
						, max(BYTES_CACHED-BYTES_USED) LARGEST, count(*) CHUNKS , '*' TMP
                       			from v\$temp_extent_pool
                       			group by TABLESPACE_NAME
                		) a
                	group by a.TABLESPACE_NAME,a.TMP
               	     ) aa
        	     ,
		     (select TABLESPACE_NAME, STATUS, CONTENTS, EXTENT_MANAGEMENT, ALLOCATION_TYPE
				from dba_tablespaces
		     ) bb
        	where bb.TABLESPACE_NAME = aa.TABLESPACE
        	order by aa.TABLESPACE;";;
	*) RunSql2Html 9999 "Tablespace overview" "column TOT_SIZE format 999,999,999,999
     		column TOT_FREE format 999,999,999,999
     		column PCT format 999 Heading \"%USED\"
     		column FRAGS format 9,999,999
     		col TABLESPACE form a25
     		col BLOCK_SIZE form 999999
     		col STATUS form a15
     		col CONTENTS form a12
     		col EXTENT_MANAGEMENT form a12 heading \"EXTMAN\"
     		col ALLOCATION_TYPE form a12 heading \"ALLOCTYPE\"
     		col SEGMENT_SPACE_MANAGEMENT form a12 heading \"SEGMAN\"
     		set echo off
     		select aa.TABLESPACE
			, STATUS
			, BLOCK_SIZE
			, CONTENTS
			, EXTENT_MANAGEMENT
			, ALLOCATION_TYPE
			, SEGMENT_SPACE_MANAGEMENT
			, TOT_SIZE
			, TOT_FREE
			, PCT
			, FRAGS
        	from (
                	select substr(a.TABLESPACE_NAME,1,25) TABLESPACE,
                	sum(a.TOTS) TOT_SIZE,
                	sum(a.SUMB) TOT_FREE,
                	round(100-sum(a.SUMB)*100/sum(a.TOTS),1) PCT,
                	sum(a.LARGEST) MAX_FREE,sum(a.CHUNKS) FRAGS,
                	TMP
                	from (select TABLESPACE_NAME,0 TOTS,sum(BYTES) SUMB, max(BYTES) LARGEST,count(*) CHUNKS, null TMP
                       			from dba_free_space a
                       			group by TABLESPACE_NAME
                		union
                       			select TABLESPACE_NAME,sum(BYTES) TOTS,0,0,0, null TMP 
					from dba_data_files
                       			group by TABLESPACE_NAME
                		union
                       			select TABLESPACE_NAME, sum(BYTES) TOTS,0,0,0, '*' TMP 
					from dba_temp_files
                       			group by TABLESPACE_NAME
                		union
                       			select TABLESPACE_NAME,0 TOTS, sum(BYTES_CACHED-BYTES_USED) SUMB
						, max(BYTES_CACHED-BYTES_USED) LARGEST, count(*) CHUNKS , '*' TMP
                       			from v\$temp_extent_pool
                       			group by TABLESPACE_NAME
                		) a
                	group by a.TABLESPACE_NAME,a.TMP
               	     ) aa
        	     ,
		     (select TABLESPACE_NAME
				, BLOCK_SIZE
				, STATUS
				, CONTENTS
				, EXTENT_MANAGEMENT
				, ALLOCATION_TYPE
				, SEGMENT_SPACE_MANAGEMENT
			from dba_tablespaces
		     ) bb
        	where bb.TABLESPACE_NAME = aa.TABLESPACE
        	order by aa.TABLESPACE;";;
    esac
    return $?
    }

#---------------------------
# Get an overview over when 
# the tablespaces in the database
# has been added to.
# Input : None
# Output: return code
#---------------------------
GetTablespaceIncreases ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "This query shows increases in allocated database storage, based on file creation time for all datafiles."
        AddText info "It gives an overview, but it is inaccurate if :"
        AddText info " - A file has been resized since it was created."
        AddText info " - A file has been deleted from the database.\n"
    fi
    RunSql2Html 999 "Database space allocation (based on file creation time)" "col \"ADDED MB\" form 999,999,999
        select to_char(CREATION_TIME,'YYYY MM') MONTH, round(sum(BYTES)/1024/1024,0) \"ADDED MB\"
        from v\$datafile
        group by to_char(CREATION_TIME,'YYYY MM');"
    return $?
    }

#---------------------------
# Get a list of tablespaces 
# not listed as online.
# Input : None
# Output: return code
#---------------------------
GetTablespaceStatus ()
    {
    RunSql2Html 999 "Tablespaces not listed online" "select TABLESPACE_NAME, STATUS
            from dba_tablespaces
            where STATUS != 'ONLINE';" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS tablespaces not listed as online" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Get a list of temporary tablespaces 
# Input : None
# Output: return code
#---------------------------
GetTempTablespaces ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "When a temporary tablespace is created, it has to be created with the TEMPORARY option"
        AddText info "for oracle to be able to distinguish it from a regular tablespace."
        AddText info "\nIf the tablespace intended to be temporary is NOT listed below,"
        AddText info "correct this by issuing the sql statement:"
        AddText info "alter tablespace TABLESPACE_NAME temporary;"
        AddText info "\nThe oracle-recommended storage parameters for a temporary tablespace are:"
        AddText info "initial = next = (multiple of SORT_AREA_SIZE + DB_BLOCK_SIZE), pctincrease = 0\n"
        AddText info "\nOracle version 10g introduces the consept of temporary tablespace groups to"
        AddText info "help large sort operations finish, and to let parallel queries and sessions use"
        AddText info "separate temp tablespaces."
    fi
    # For 10g only ...
    case $DBINFO_DB_VERSION_SHORT in
        1*) 	RunSql2Html 999 "Temporary tablespace groups" "select * from dba_tablespace_groups;"
            if [ $? -ne 0 ] ; then
                echo "\nUnable to retrieve information about temporary tablespace groups"
                echo "$ORACLE_SID : Unable to retrieve information about temporary tablespace groups" >> $DBINFO_HTML_STATUS
            else
                echo ""
            fi;;
    esac

    OUTPUT=$(RunSql2Html 9999 "Temporary tablespaces" "select TABLESPACE_NAME, INITIAL_EXTENT, NEXT_EXTENT, PCT_INCREASE, STATUS, CONTENTS
            from dba_tablespaces
            where CONTENTS='TEMPORARY';")
    echo "$OUTPUT" | grep -q TEMPORARY 
    if [ $? -eq 0 ] ; then
        echo "$OUTPUT"
        return 0
    else
        echo "\nThis database has no temporary tablespaces defined."
        [ $DBINFO_RETURNED_ROWS -eq 0 ] && echo "$ORACLE_SID : Database has no temporary tablespaces defined" >> $DBINFO_HTML_STATUS
        return 1
    fi
    }

#---------------------------
# List locally managed tablespaces
# Input : None
# Output: return code
#---------------------------
GetLocalTablespaces ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Locally managed tablespaces do not rely on the central data dictionary tables to keep"
        AddText info "track of datafiles and storage allocation (extent management). Instead, they set aside a small area"
        AddText info "of each datafile to store the necessary information about free and used blocks that"
        AddText info "are available."

        AddText info "\nLocally managed tablespaces feature 2 modes of extent management: AUTOALLOCATE and UNIFORM."
        AddText info "AUTOALLOCATE means oracle decides which extentsizes to use, while UNIFORM sets a default"
        AddText info "size for all extents. 9i databases also features optional automatic segment management"
        AddText info "to set values like PCTUSED and PCTFREE."

        AddText info "\nLocally managed tablespaces provide several benefits, and is the default method of extent management"
        AddText info "from oracle 9i and up :"
        AddText info " - Less overhead, as locally managed tablespaces generally doesn't generate rollback information."
        AddText info " - Reduced contention for dictionary tables."
        AddText info " - Automatic tracking of adjacent freespace decreases fragmentation (no coalesce needed)"
        AddText info " - Simplified extent management"

        AddText info "\nLocally managed system tablespaces are supported from oracle version 8.1.6 and up.\n"
    fi
    case $DBINFO_DB_VERSION_SHORT in
        7*|80* )	echo "Locally managed tablespaces are not available for pre-8i databases"
                return 0;;
        81*)		RunSql2Html 999 "Locally managed tablespaces" "set lines 300
                    col TABLESPACE_NAME form a25 truncate heading TABLESPACE
                    col INITIAL_EXTENT form 999,999,999 heading \"INITIAL\"
                    col NEXT_EXTENT form 999,999,999 heading \"NEXT\"
                    col ALLOCATION_TYPE form a8 heading ALLOC
                    col SEGMENT_SPACE_MANAGEMENT form a8 heading \"MANAGED\"
                    select TABLESPACE_NAME
                        , CONTENTS
                        , INITIAL_EXTENT
                        , NEXT_EXTENT
                        , ALLOCATION_TYPE
                    from dba_tablespaces
                    where EXTENT_MANAGEMENT = 'LOCAL';" ;;
        9*|1*)		RunSql2Html 999 "Locally managed tablespaces" "set lines 300
                    col TABLESPACE_NAME form a25 truncate heading TABLESPACE
                    col INITIAL_EXTENT form 999,999,999 heading \"INITIAL\"
                    col NEXT_EXTENT form 999,999,999 heading \"NEXT\"
                    col ALLOCATION_TYPE form a8 heading ALLOC
                    col SEGMENT_SPACE_MANAGEMENT form a8 heading \"MANAGED\"
                    select TABLESPACE_NAME
                        , CONTENTS
                        , INITIAL_EXTENT
                        , NEXT_EXTENT
                        , ALLOCATION_TYPE
                        , SEGMENT_SPACE_MANAGEMENT
                    from dba_tablespaces
                    where EXTENT_MANAGEMENT = 'LOCAL';" ;;
    esac
    return $?
    }

#---------------------------
# List transportable tablespaces
# Input : None
# Output: return code
#---------------------------
GetTransTablespaces ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        7*|80* )	echo "\nTransportable tablespaces are not available for pre-8i databases"
                return 0;;
    esac

    RunSql2Html 999 "Transportable tablespaces" "select TABLESPACE_NAME, STATUS, CONTENTS
            , EXTENT_MANAGEMENT, PLUGGED_IN
            from dba_tablespaces
            where PLUGGED_IN <> 'NO';"
    return $?
    }

#---------------------------
# List bigfile tablespaces
# Input : None
# Output: return code
#---------------------------
GetBigfileTablespaces ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Bigfile tablespaces was introduced in oracle vesion 10g"
        AddText info "These tablespaces consist of a single file only, with a maximum size of 128TB on tablespaces"
        AddText info "with a 32K blocksize. Maximum bloxksize is 4G."
        AddText info "It's main functionality is ease of administration. The major drawback is time for backup and recovery."
        AddText info "Bigfile tablespaces is only supported for locally managed tablespaces with automatic segment space management (ASSM)."
    fi
    case $DBINFO_DB_VERSION_SHORT in
        1* )	RunSql2Html 999 "Bigfile tablespaces" "col TABLESPACE_NAME form a25
            col FILE_NAME form a60 truncate
            select TABLESPACE_NAME
                , FILE_ID
                , FILE_NAME
                , round(BYTES/1024/1024,0) MB
                , AUTOEXTENSIBLE AUTO
                , round(MAXBYTES/1024/1024,0) MAX_MB 
            from dba_data_files
            where TABLESPACE_NAME in (select TABLESPACE_NAME from dba_tablespaces where BIGFILE != 'NO');"
            return $?;;
        * )	echo "\nBigfile tablespaces are not available for version prior to 10g"
            return 0;;
    esac
    }

#---------------------------
# Get a summary of tablespace fragmentation
# Input : None
# Output: return code
#---------------------------
GetTablespaceFragmentation ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Heavily fragmented tablespaces can have an impact on the performance, especially when"
        AddText info "a lot of full table scans are occurring on the system."
        AddText info "Another disadvantage of fragmentation is that the database will not be able to re-use"
        AddText info "the smaller freespace-segments because the indexes and tables are requesting larger extents"
        AddText info "than what the tablespace has available."
        AddText info "The only way to resolve fragmentation is to recreate the objects in the tablespace."
        AddText info "\nNote that you can decrease reported fragmentation by running a coalesce on each tablespace:"
        AddText info "alter tablespace TABLESPACE_NAME coalesce;\n"
    fi
    #
    # Seems like a high value for chunks/frags is the best indicator of 
    # a fragmented tablespaces.
    # The best available advice on a threshold value for frags so far is 50
    # , so we'll go with 100 here.
    #
    RunSql2Html 9999 "Fragmented tablespaces" "set linesize 2000
        col \"MINSIZE KB\" form 999,999
        col \"MAXSIZE MB\" form 999,999
        select * from (
        select TABLESPACE_NAME
            , round(sum(SMALL)/1024,2)  \"MINSIZE KB\"
            , round(sum(LARGE)/1024/1024,0)  \"MAXSIZE MB\"
            , sum(Frag) "Frags"
        from (select TABLESPACE_NAME, min(BYTES)  SMALL , 0 LARGE , 0 FRAG
            from dba_free_space
            group by TABLESPACE_NAME
            union
            select TABLESPACE_NAME, 0 , max(BYTES) LARGEST, 0
            from dba_free_space
            group by TABLESPACE_NAME
            union
            select TABLESPACE_NAME, 0, 0 , count(*) FRAG
            from dba_free_space
            group by TABLESPACE_NAME)
            group by TABLESPACE_NAME)
        where FRAGS > 99
        and TABLESPACE_NAME not in (select TABLESPACE_NAME 
                from dba_tablespaces where CONTENTS='TEMPORARY')
        order by TABLESPACE_NAME;" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database reports $DBINFO_RETURNED_ROWS fragmented tablespaces" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info for RBS
# Input : None
# Output: Info on stdout
#---------------------------
GetRbsInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Rollback segments record all the changes that transactions perform on the database."
        AddText info "This information is used to rollback transaction, provide read consistency and"
        AddText info "to perform database recovery."
        AddText info "\nDatabases that are used for small transactions generally requires smaller rollback segments"
        AddText info "than databases that run larger jobs (ie batch jobs). Sizing of rollback segments will"
        AddText info "affect both database performance, and may decide wether a query is successfull or not."
        AddText info "\nRollback segments should be created in tablespaces dedicated for this use, and"
        AddText info "with a correct OPTIMAL size."
        AddText info "\nAs a guideline, OPTIMAL for a given rollback segment should be set slightly higher"
        AddText info "than the AVEACTIVE value, retrieved by querying the view v\$rollstat."
        AddText info "\nAlso, a high value for SHRINKS indicates that the OPTIMAL size is set too low."
        AddText info "Low values for SHRINKS and AVESHRINK indicates a too high OPTIMAL setting,"
        AddText info "unless AVEACTIVE is about equal to OPTIMAL."
        AddText info "\nIf WAITS has a non-zero value for any rollback segment, you may need to add more segments.\n"
    fi

    RunSql2Html 9999 "Rollback segment information" "set lines 200
            col USN form 999
            col NAME form a12 truncate
            col TABLESPACE_NAME form a25 truncate heading TABLESPACE
            col STATUS form a8
            col INITIAL_EXTENT form 999,999,999 heading \"INITIAL\"
            col NEXT_MB form 999,999,999
            col MINEXT form 999,999
            col EXTENTS form 99,999 heading \"#EXT\"
            col WAITS form 99,999
            col OPT_MB form 99,999
            col HWM_MB form 999,999
            col SHRINKS form 99,999
            col AVESHRINK form 999,999,999
            col AVEACTIVE form 9,999,999,999
            select rn.USN USN
                , rn.NAME NAME
                , drs.TABLESPACE_NAME 
                , drs.STATUS
                , drs.INITIAL_EXTENT 
                , drs.NEXT_EXTENT NEXT
                , drs.MIN_EXTENTS MINEXT
                , rs.EXTENTS 
                , rs.WAITS
                , rs.SHRINKS
                , round(rs.OPTSIZE/1024/1024,0) OPT_MB
                , round(rs.HWMSIZE/1024/1024,0) HWM_MB
                , rs.AVESHRINK
                , rs.AVEACTIVE
            from dba_rollback_segs drs
                , v\$rollstat rs
                , v\$rollname rn
            where drs.SEGMENT_NAME=rn.NAME
                and rs.USN=rn.USN;"
    return $?
    }

#---------------------------
# Get basic information about 
# undo tablespaces.
# Input : None
# Output: Info on stdout
#---------------------------
GetUndoInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "For databases prior to 9i, undo information is stored in rollback segments until a commit or rollback" 
        AddText info "statement is issued. This method is referred to as manual undo management."
        AddText info "\n9i reduces undo management and tuning by introducing automatic undo management and UNDO tablespaces."
        AddText info "Undo tablespaces enables the oracle database to keep track of changes for a specified duration"
        AddText info "before purging it. This enables flashback queries, and prevents 'snapshot too old' errors"
        AddText info "for long-running queries.\n"
    fi
        case $DBINFO_DB_VERSION_SHORT in
                7*|8* )        echo "\nUndo tablespaces are not available for pre-9i databases"
                                return 0;;
        esac
    # The functionality provided by the traditional RBS is now referred to as manual undo
    # The undo tablespaces provide 'automatic undo management mode' 

    RunSql2Html 9999 "Undo Retention" "col NAME form a35
                col VALUE form a80
                select INST_ID, NAME, VALUE 
		from gv\$parameter 
                where NAME='undo_retention' 
                order by INST_ID;"
    
    echo ""
    RunSql2Html 9999 "Undo tablespaces" "select TABLESPACE_NAME
		, INITIAL_EXTENT
		, NEXT_EXTENT
            	, PCT_INCREASE
		, STATUS
		, CONTENTS
		, LOGGING
		, EXTENT_MANAGEMENT
		, PLUGGED_IN
            from dba_tablespaces where CONTENTS like '%UNDO%';"
    return $?
    }

#---------------------------
# Print info about segements
# that should be relocated because
# they're in the wrong tablespace.
# Input : None
# Output: Info on stdout
#---------------------------
GetRelocSegs ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "User objects should not be created in the system tablespace, as this can lead to fragmentation"
        AddText info "and also prevent necessary system tables from extending themselves."  
        AddText info "Also note that some users/schemas are created by default when you install oracle, and"
        AddText info "that some of these objects may be placed in the SYSTEM tablespace."
        AddText info "Don't remove or relocate segments unless you are absolutely sure this does not cause any problems"
        AddText info "\nPermanent segments (tables/indexes) should not be located in tablespaces marked as TEMPORARY\n"
    fi
    RunSql2Html 9999 "Segments in the SYSTEM tablespace" "set lines 300
            col SEGMENT_NAME form a30
            col SEGMENT_TYPE form a16
            col OWNER form a20
            col TABLESPACE_NAME form a25 heading TABLESPACE
            col PARTITION_NAME form a20 truncate heading PARTITION
            break on OWNER
            select OWNER, SEGMENT_TYPE, SEGMENT_NAME, PARTITION_NAME, TABLESPACE_NAME
            from dba_segments
            where TABLESPACE_NAME='SYSTEM'
            and OWNER not in ('SYS','SYSTEM','OUTLN')
            order by OWNER;" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Tablespace SYSTEM contains $DBINFO_RETURNED_ROWS segments that are candidates for relocation" >> $DBINFO_HTML_STATUS
    echo "\n"
    RunSql2Html 9999 "Segments located in TEMPORARY tablespaces" "set lines 300
            col SEGMENT_NAME form a30
            col TABLESPACE_NAME form a25 heading TABLESPACE
            col OWNER form a15
            col SEGMENT_TYPE form a16
            select SEGMENT_TYPE
		, OWNER
		, SEGMENT_NAME
		, round(BYTES/1024/1024,0) MB
		, TABLESPACE_NAME
            from dba_segments
            where TABLESPACE_NAME in (select TABLESPACE_NAME 
                        from dba_tablespaces 
			where CONTENTS='TEMPORARY')
            and SEGMENT_TYPE <> 'TEMPORARY';" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Temporary tablespace(s) contains $DBINFO_RETURNED_ROWS permanent segments" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info about segements
# that are running out of allowable extents
# Input : None
# Output: Info on stdout
#---------------------------
GetMaxExtents ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Database segments that reach the maximum specified number of extents will fail when they try"
        AddText info "to allocate more space for data."
        AddText info "To increase the max extents value, execute this sql for every segment that is affected :"
        AddText info "alter SEGMENT_NAME storage (maxextents NEW_VALUE);\n"
    fi
    RunSql2Html 9999 "Segments within 5 extents of maxextents" "col SEGMENT_NAME form a30 truncate
        col OWNER form a20 truncate
        col TABLESPACE_NAME form a25 truncate heading TABLESPACE
        col SEGMENT_TYPE form a10 heading T/I
        col \"NEXT (KB)\" form 9,999,999
        col EXTENTS form 99,999
        col MAX_EXTENTS form 99,999 heading MAXEXT
        select SEGMENT_TYPE
		, OWNER
		, SEGMENT_NAME
		, TABLESPACE_NAME 
		, EXTENTS
		, MAX_EXTENTS
		, round(NEXT_EXTENT/1024,0) \"NEXT (KB)\"
        from dba_segments
        where EXTENTS+5 >= MAX_EXTENTS
        and SEGMENT_TYPE in ('TABLE','INDEX');" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS segment(s) reaching the maxextents limit" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info about segements
# that can't allocate the next extent
# Input : None
# Output: Info on stdout
#---------------------------
GetNextExtent ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "When the database tablespaces run out of contiguous free space, segments which request large datablocks"
        AddText info "for their next extent may not receive this."
        AddText info "If this happens, expand the tablespace that is running out of space, or decrease the size"
        AddText info "of the next extent for the offending segment.\n\nFor example:"
        AddText info "alter SEGMENT_NAME storage (next NEW_VALUE M);"
        AddText info "alter tablespace TABLESPACE_NAME add datafile 'DATAFILE_NAME' size NEW_VALUE M;"
        AddText info "alter database datafile 'DATAFILE_NAME' resize NEW_VALUE M;\n"
    fi
    RunSql2Html 9999 "Segments unable to allocate next extent" "col SEGMENT_NAME form a30
            col SEGMENT_TYPE form a16
            col OWNER form a18 truncate
            col \"NEXT (KB)\" form 999,999,999
            break on s.OWNER
            select s.OWNER
		, s.SEGMENT_TYPE
		, s.SEGMENT_NAME
		, s.PARTITION_NAME
		, s.TABLESPACE_NAME
		, round(s.NEXT_EXTENT/1024,0) \"NEXT (KB)\"
            from dba_segments s
            where s.NEXT_EXTENT > (select max(f.BYTES)
            				from dba_free_space f
            				where f.TABLESPACE_NAME = s.TABLESPACE_NAME)
            and s.SEGMENT_TYPE != 'ROLLBACK'
            order by s.OWNER;" || return $?
    AddText std "\nThe above test doesn't report on segments in tablespaces with automatic segment management.\n"
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS segment(s) unable to allocate next extent" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info about segements
# that are using a large number of extents
# Input : None
# Output: Info on stdout
#---------------------------
GetExcessiveExtents ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Having occasional segments that are spread over a large number of extents does not generally degrade"
        AddText info "database performance significantly."
        AddText info "If, however, the database has a lot of segments where this is the case, performance may suffer."
        AddText info "To fix this, recreate the segments with larger extent sizes."
        AddText info "(export/import, create as .. etc)\n"
    fi
    # Oracle suggests that all segments using more than 100-200 extents are candidates for recreation.
    # We'll try using 200 as a limit here.
    RunSql2Html 9999 "Potentially overextended segments" "col SEGMENT_NAME form a25 truncate
            col SEGMENT_TYPE form a16 truncate
            col OWNER form a15 truncate
            col TABLESPACE_NAME form a25 truncate heading TABLESPACE
            col PARTITION form a20 truncate
            col EXTENTS form 99,999 heading \"#EXT\"
            col MAX_EXTENTS form 99,999,999,999 heading \"MAXEXT\"
            select SEGMENT_TYPE
		, OWNER
		, SEGMENT_NAME
		, PARTITION_NAME PARTITION
		, TABLESPACE_NAME
		, EXTENTS
		, MAX_EXTENTS
            from dba_segments
            where EXTENTS > 199
            and SEGMENT_TYPE <> 'TEMPORARY'
            order by EXTENTS desc;" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS segment(s) with an excessive extent count" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info about submitted jobs
# Input : None
# Output: Info on stdout
#---------------------------
GetDBJobs ()
    {
    RunSql2Html 999 "Submitted jobs" "set linesize 2000
        col JOB format a50 truncate
        col OK   format a2  
        col SUBMITTER form a16 truncate
        col SECURITY form a16 truncate
        select  JOB	ID 
        	, LOG_USER  SUBMITTER
        	, PRIV_USER SECURITY 
        	, WHAT      JOB
                , to_char(LAST_DATE,'MM/DD')||' '||substr(LAST_SEC,1,5) LAST_OK_RUN
                , to_char(NEXT_DATE,'MM/DD')||' '||substr(NEXT_SEC,1,5) NEXT_RUN
        	, FAILURES ERR
        	, decode(BROKEN,'Y','N','Y') OK 
        from 
        sys.dba_jobs;" || return $?
    }


#---------------------------
# Print info about tablespace storage quotas pr user
# Input : None
# Output: Info on stdout
#---------------------------
GetTsQuota ()
	{
	RunSql2Html 9999 "dba_ts_quotas" "select TABLESPACE_NAME
        	, USERNAME
        	, round(BYTES/1024/1024,0) USED_MB
        	, decode(MAX_BYTES,-1,'unlimited',round(MAX_BYTES/1024/1024,0)) MAX_MB
	from dba_ts_quotas
	order by TABLESPACE_NAME, USERNAME;"
	return $?
	}

#---------------------------
# Print info about database users
# Input : None
# Output: Info on stdout
#---------------------------
GetUsersInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "No users except SYS and SYSTEM should have SYSTEM as the default and/or temporary tablespace."
        AddText info "To prevent fragmentation, the SYS and SYSTEM users can safely be given"
        AddText info "another temporary tablespace than the default value SYSTEM.\n"
    fi
    RunSql2Html 999 "Database users" "set linesize 2000
        col USERNAME form a20
        col PASSWORD form a20
        col DEF_TBLSPC form a20
        col TMP_TBLSPC form a15
        col PROFILE form a10
        col STATUS form a18
        col MB_USED form 999,999,999
        select  USERNAME
		, USER_ID ID
		, PASSWORD
		, DEFAULT_TABLESPACE DEF_TBLSPC
		, TEMPORARY_TABLESPACE TMP_TBLSPC
		, CREATED
		, PROFILE
		, ACCOUNT_STATUS STATUS
		, round(sum(BYTES/1024/1024),0) MB_USED
            from dba_users du
		, dba_segments ds
            where USERNAME=OWNER
            group by USERNAME
		, USER_ID
		, PASSWORD
		, DEFAULT_TABLESPACE
		, TEMPORARY_TABLESPACE
		, CREATED
		, PROFILE
		, ACCOUNT_STATUS;"
    return $?
    }

#---------------------------
# Print info about database roles
# Input : None
# Output: Info on stdout
#---------------------------
GetRoleInfo ()
    {
    RunSql2Html 9999 "Database roles" "set linesize 2000
        select * 
	from dba_roles
        order by ROLE;"
    return $?
    }

#---------------------------
# Print info about database 
# users with bad roles assigned
# Input : None
# Output: Info on stdout
#---------------------------
GetBadRoles ()
    {
    RunSql2Html 999 "Worrying database roles" "break on GRANTEE
    select GRANTEE, GRANTED_ROLE, ADMIN_OPTION
    from   sys.dba_role_privs 
    where  GRANTED_ROLE in ('DBA', 'AQ_ADMINISTRATOR_ROLE',
               'EXP_FULL_DATABASE', 'IMP_FULL_DATABASE',
               'OEM_MONITOR')
    and  GRANTEE not in ('SYS', 'SYSTEM', 'OUTLN', 'AQ_ADMINISTRATOR_ROLE',
               'DBA', 'EXP_FULL_DATABASE', 'IMP_FULL_DATABASE',
               'OEM_MONITOR', 'CTXSYS', 'DBSNMP', 'IFSSYS',
               'IFSSYS$CM', 'MDSYS', 'ORDPLUGINS', 'ORDSYS',
               'TIMESERIES_DBA')
    order by GRANTEE;" 
    return $?
    }

#---------------------------
# Print info about database 
# users with bad roles assigned
# Input : None
# Output: Info on stdout
#---------------------------
GetBadPrivs ()
    {
    RunSql2Html 999 "Worrying database privileges" "break on grantee
	select GRANTEE, PRIVILEGE, ADMIN_OPTION
        from   sys.dba_sys_privs 
        where  (privilege like '% ANY %'
        or   PRIVILEGE in ('BECOME USER', 'UNLIMITED TABLESPACE')
        or   ADMIN_OPTION = 'YES')
        and   GRANTEE not in ('SYS', 'SYSTEM', 'OUTLN', 'AQ_ADMINISTRATOR_ROLE',
               'DBA', 'EXP_FULL_DATABASE', 'IMP_FULL_DATABASE',
               'OEM_MONITOR', 'CTXSYS', 'DBSNMP', 'IFSSYS',
               'IFSSYS$CM', 'MDSYS', 'ORDPLUGINS', 'ORDSYS',
               'TIMESERIES_DBA')
        order by GRANTEE;"
    return $?
    }

#---------------------------
# Print info about users that 
# are identified externally
# Input : None
# Output: Info on stdout
#---------------------------
GetBadUsers ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "When creating a database user it is possible to specify EXTERNAL authentication."
        AddText info "If a connection to the database is then made from an OS user with the same name as the"
        AddText info "database user, oracle will not demand any user authentication, but instead trust the"
        AddText info "calling (local or remote) operating system to have verified the credentials"
        AddText info "of that particular OS user." 
        AddText info "\nThis leaves a gaping hole in the database security, and should not be allowed."
        AddText info "Any user listed below should be modified to use password authentication by issuing the command:"
        AddText info "alter user USERNAME identified by NEW_PASSWORD;\n"
    fi
    RunSql2Html 9999 "Externally identified users" "select USERNAME, PASSWORD 
	from dba_users 
	where PASSWORD = 'EXTERNAL';" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS externally identified users" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info about users that
# are listed ass password file 
# users.
# Input : None
# Output: Info on stdout
#---------------------------
GetPwFileUsers ()
    {
    RunSql2Html 9999 "Password file users" "select * from v\$pwfile_users;" 
    return $?
    }

#---------------------------
# Print info about database profiles
# Input : None
# Output: Info on stdout
#---------------------------
GetProfileSettings ()
    {
    RunSql2Html 9999 "DBA Profiles" "select PROFILE
	, RESOURCE_NAME
	, RESOURCE_TYPE
	, LIMIT 
	from dba_profiles
	order by PROFILE
		, RESOURCE_TYPE
		, RESOURCE_NAME;"
    return $?
    }

#---------------------------
# Print info about invalid objects
# in the database.
# Input : None
# Output: Info on stdout
#---------------------------
GetInvalidObjects ()
    {
    RunSql2Html 9999 "Invalid objects" "col OWNER form a20
        col OBJECT_NAME form a40
        select OWNER
		, OBJECT_NAME
		, OBJECT_TYPE
		, STATUS 
	from dba_objects 
	where STATUS = 'INVALID'
        order by OWNER
		, OBJECT_NAME;" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS invalid objects" >> $DBINFO_HTML_STATUS
    return 0
    }

#---------------------------
# Print info about objects
# per user
# Input : None
# Output: Info on stdout
#---------------------------
GetObjectInfo ()
    {
    # Might update this with other object types. DIRECTORY, TRIGGER, etc
    RunSql2Html 9999 "Database objects summary" "set linesize 2000
            col OWNER format a20 heading "Owner"
            col SUM_TABLE format 999,999 heading "TABLES"
            col SUM_INDEX format 999,999 heading "INDEXES"
            col SUM_VIEW format 999,999 heading "VIEWS"
            col SUM_SEQUENCE format 999,999 heading "SEQUENCES"
            col SUM_SYNONYM format 999,999 heading "SYNONYMS"
            col SUM_CLUSTER format 999,999 heading "CLUSTERS"
            col SUM_PROCEDURE format 999,999 heading "PROCEDURES"
            col SUM_PACKAGE format 999,999 heading "PACKAGES"
            col SUM_PACKAGE_BODY format 999,999 heading \"PCKG BODIES\"
            col SUM_DB_LINK format 999,999 heading \"DB LINKS\"
# YYY
            compute sum of SUM_TABLE on report
            compute sum of SUM_INDEX on report
            compute sum of SUM_VIEW on report
            compute sum of SUM_SEQUENCE on report
            compute sum of SUM_SYNONYM on report
            compute sum of SUM_CLUSTER on report
            compute sum of SUM_PROCEDURE on report
            compute sum of SUM_PACKAGE on report
            compute sum of SUM_PACKAGE_BODY on report
            compute sum of SUM_DB_LINK on report
            select o.OWNER,
            sum( decode( o.OBJECT_TYPE, 'TABLE', 1, 0 ) ) as "SUM_TABLE",
            sum( decode( o.OBJECT_TYPE, 'INDEX', 1, 0 ) ) as "SUM_INDEX",
            sum( decode( o.OBJECT_TYPE, 'VIEW', 1, 0 ) ) as "SUM_VIEW",
            sum( decode( o.OBJECT_TYPE, 'SEQUENCE', 1, 0 ) ) as "SUM_SEQUENCE",
            sum( decode( o.OBJECT_TYPE, 'SYNONYM', 1, 0 ) ) as "SUM_SYNONYM",
            sum( decode( o.OBJECT_TYPE, 'CLUSTER', 1, 0 ) ) as "SUM_CLUSTER",
            sum( decode( o.OBJECT_TYPE, 'PROCEDURE', 1, 0 ) ) as "SUM_PROCEDURE",
            sum( decode( o.OBJECT_TYPE, 'PACKAGE', 1, 0 ) ) as "SUM_PACKAGE",
            sum( decode( o.OBJECT_TYPE, 'PACKAGE BODY', 1, 0 ) ) as "SUM_PACKAGE_BODY",
            sum( decode( o.OBJECT_TYPE, 'DATABASE LINK', 1, 0 ) ) as "SUM_DB_LINK"
            from dba_objects O
            group by o.OWNER
            order by o.OWNER;"
    return $?
    }

#---------------------------
# Print info about large tables
# that are unpartitioned
# Input : None
# Output: Info on stdout
#---------------------------
GetLargeTabInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info  "Large tables should be placed in a dedicated tablespace."
        AddText info  "Extremely large tables should be partitioned.\n"
    fi
    case $DBINFO_DB_VERSION_SHORT in
        80* )   echo "\nInformation about this is currently not available for pre-8i databases"
            return 0;;
    esac
    RunSql2Html 999 "10 Largest tables" "col OWNER form a20
        col TABLE_NAME form a30
        col MB form 999,999,999
        set linesize 2000
        select * from 
            (select OWNER
		, SEGMENT_NAME TABLE_NAME
		, TABLESPACE_NAME
		, round(BYTES/1024/1024,0) MB
            from dba_segments
            where PARTITION_NAME is null
            and SEGMENT_TYPE = 'TABLE'
            order by MB desc)
        where rownum < 10;" 
    return $?
    }

#---------------------------
# Print info about partitioned
# tables
# Input : None
# Output: Info on stdout
#---------------------------
GetTabPartInfo ()
    {
    RunSql2Html 9999 "Partitioned tables" "set linesize 2000
        col OWNER form a20
        col TABLE_NAME form a40 truncate
        col MB form 999,999,999
        break on OWNER
        select OWNER
            , SEGMENT_NAME TABLE_NAME
            , count(distinct(PARTITION_NAME)) \"#PARTTIONS\"
            , count(distinct(TABLESPACE_NAME)) \"#TBLSPC\"
            , round(sum(BYTES)/1024/1024,0) MB
        from dba_segments
        where SEGMENT_TYPE='TABLE PARTITION'
        group by OWNER, SEGMENT_NAME
        order by OWNER, SEGMENT_NAME;"
    return $?
    }

#---------------------------
# Print info about large indexes
# that are unpartitioned
# Input : None
# Output: Info on stdout
#---------------------------
GetLargeIndInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Large indexes should be placed in a dedicated tablespace."
        AddText info "Extremely large indexes should be partitioned.\n"
    fi
    case $DBINFO_DB_VERSION_SHORT in
        80* )   echo "\nInformation about this is currently not available for pre-8i databases"
            return 0;;
    esac
    RunSql2Html 999 "10 Largest indexes" "col OWNER form a20
        col INDEX_NAME form a30
        col MB form 999,999,999
        set linesize 2000
        select * from
            (select OWNER
		, SEGMENT_NAME INDEX_NAME
		, TABLESPACE_NAME
		, round(BYTES/1024/1024,0) MB
            from dba_segments
            where PARTITION_NAME is NULL
            and SEGMENT_TYPE = 'INDEX'
            order by MB desc)
        where rownum < 10;"
    return $?
    }

#---------------------------
# Print info about partitioned
# indexes
# Input : None
# Output: Info on stdout
#---------------------------
GetIndPartInfo ()
    {
    RunSql2Html 9999 "Partitioned indexes" "set linesize 2000
        col OWNER form a20
        col INDEX_NAME form a40 truncate
        col MB form 999,999,999
        break on OWNER
        select OWNER
            , SEGMENT_NAME INDEX_NAME
            , count(distinct(PARTITION_NAME)) \"#PARTTIONS\"
            , count(distinct(TABLESPACE_NAME)) \"#TBLSPC\"
            , round(sum(BYTES)/1024/1024,0) MB
        from dba_segments
        where SEGMENT_TYPE='INDEX PARTITION'
        group by OWNER, SEGMENT_NAME
        order by OWNER, SEGMENT_NAME;"
    return $?
    }

#---------------------------
# Print info about chaining
# and migration.
# Input : None
# Output: Info on stdout
#---------------------------
GetChainingInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Chaining occurs when an inserted row is too large to fit into a single datablock."
        AddText info "Oracle then stores the data in a chain of datablocks that are reserved for this"
        AddText info "segment alone.\n"
        AddText info "Migration occurs when a row is updated so that it can no longer fit in a single datablock."
        AddText info "The row is then moved to a new datablock, and the old location is updated with a pointer to the new"
        AddText info "location.\n"
        AddText info "Both chaining and migration decrease oracle performance significantly."
        AddText info "Migration can be decreased by increasing the PCTFREE setting for segments."
        AddText info "Chaining can only be decreased by recreating the database using a larger data blocksize."
        AddText info "\nNote : This test requires the tables to have statistics, and is wildy inaccurate if"
        AddText info " 1) The statistics are old"
        AddText info " 2) The sample size for the statstics is small."
        AddText info " 3) The statistics have been gathered using the dbms_stats pacakge."
        AddText info "In all other cases it's probably just inaccurate..."
        AddText info "The oracle dbms_stats package only collects statistics needed for cost-based optimization"
        AddText info "of queries, and doesn't supply chaining values."
        AddText info "Also - finding good advice on a threshold value seems impossible. Here we're using 10%\n"
    fi
    RunSql2Html 9999 "Chaining statistics for all analyzed tables" "col OWNER form a20
            break on OWNER
            select OWNER
		, TABLE_NAME
		, TABLESPACE_NAME TABLESPACE
		, NUM_ROWS \"#ROWS\"
		, CHAIN_CNT \"#CHAINS\"
		, LAST_ANALYZED ANALYZED
		, SAMPLE_SIZE SAMPLE
		, round(CHAIN_CNT*100/NUM_ROWS,0) \"% CHAINED\"
            from dba_tables
            where LAST_ANALYZED is not null
            and (CHAIN_CNT/NUM_ROWS)*100 > 10
            and CHAIN_CNT > 0
            order by OWNER;" || return $?
    [ $DBINFO_RETURNED_ROWS -gt 0 ] && echo "$ORACLE_SID : Database reports $DBINFO_RETURNED_ROWS tables with high chaining" >> $DBINFO_HTML_STATUS

    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "The following value is a general value that shows how many chained rows the database"
        AddText info "has fetched since system startup. It doesn't really tell anything spesific, but might be"
        AddText info "useful as a really general guide."
    fi
    RunSql2Html 999 "Chained rows read since database startup" \
        "select NAME, VALUE from v\$sysstat where name = 'table fetch continued row';" || return $?
    return 0
    }


#---------------------------
# Print info about objects residing in the SYSAUX tablespace
# Input : None
# Output: Info on stdout
#---------------------------
GetSysauxInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "The SYSAUX tablespace is a required tablespace introduced in Oracle version 10g."
        AddText info "In version prior to 10g, metadata for oracle options and features like OLAP, Logminer,"
        AddText info "Intermedia, etc. where stored in separate tablespaces or/and in the SYSTEM tablespace by default."
        AddText info "10g consolidates all these tablespaces into one single tablespace called SYSAUX."
        AddText info "The main advantages of doing this is ease of administration, and less pressure and fragmentation"
        AddText info "in the SYSTEM tablespace."
    fi
        case $DBINFO_DB_VERSION_SHORT in
                7*|8*|9* )   echo "\nInformation about this is not available for databases prior to 10g"
                        return 0;;
        esac
    RunSql2Html 999 "v\$sysaux_occupants" "set lines 200
                col OCCUPANT_NAME form a15
                col OCCUPANT_DESC form a55
                col SCHEMA_NAME form a20
                col MOVE_PROCEDURE form a35
                col SIZE_KB form 999,999,999
                select OCCUPANT_NAME
                    , OCCUPANT_DESC
                    , SCHEMA_NAME
                    , MOVE_PROCEDURE
                    , SPACE_USAGE_KBYTES SIZE_KB
                from v\$sysaux_occupants;"
    return $?
    }


#---------------------------
# Print minimal information about snapshots
# Input : None
# Output: Info on stdout
#---------------------------
GetSnapshotInfo ()
    {
#	if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
#		AddText info ""
#		AddText info "\n"
#	fi
    RunSql2Html 9999 "Snapshot overview by owner, status and type" "set lines 200
            col MASTER_LINK form a18
            col MASTER_OWNER form a18
            col OWNER form a18
            break on OWNER
            select OWNER, count(*), STATUS, REFRESH_METHOD
            from dba_snapshots
            group by OWNER, STATUS, REFRESH_METHOD
            order by OWNER, STATUS, REFRESH_METHOD;" || return $?
    echo ""
    RunSql2Html 9999 "Snapshot logs" "break on LOG_OWNER
 	select * 
	from all_snapshot_logs
	order by LOG_OWNER, MASTER;"
    return $?
    }

#---------------------------
# Print directory information 
# Input : None
# Output: Info on stdout
#---------------------------
GetDirectoryInfo ()
    {
    RunSql2Html 999 "Defined directories" "col DIRECTORY_PATH form a80
	select * 
	from dba_directories
	order by OWNER, DIRECTORY_NAME;" 
    return $?
    }

#---------------------------
# Print directory information 
# Input : None
# Output: Info on stdout
#---------------------------
GetExternalTableInfo ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "External tables allows the database to read data stored in textfiles outside the database"
        AddText info "as if they were regular tables."
        AddText info "You cannot alter the data in these files, or create indexes on it.\n"
    fi
    case $DBINFO_DB_VERSION_SHORT in
        7*|8*)	AddText std "External tables are not available for pre-9i databases"
            return 0;;
    esac

    RunSql2Html 999 "External Tables" "set lines 200 pages 999
            col OWNER form a12
            col TABLE_NAME form a28
            col REJECT_LIMIT form a12
            col TYPE_NAME form a20
            col DEFAULT_DIRECTORY_NAME form a22 heading \"DIRECTORY\"
            col ACCESS_TYPE form a12 truncate heading \"ACCESS\"
            select OWNER
            , TABLE_NAME
            --, TYPE_OWNER
            , TYPE_NAME
            --, DEFAULT_DIRECTORY_OWNER
            , DEFAULT_DIRECTORY_NAME
            , REJECT_LIMIT
            , ACCESS_TYPE
            -- , ACCESS_PARAMETERS
            from dba_external_tables
            order by OWNER, TABLE_NAME;" 
    return $?
    }

#---------------------------
# Print info about sessions 
# in the database.
# Input : None
# Output: Info on stdout
#---------------------------
GetSessionInfo ()
    {
    RunSql2Html 9999 "Current database sessions" "col USERNAME form a26 truncate
        col SID form 9999
        col SERIAL form 99999
        col OSUSER form a12
        col USERNAME form a12
        col MACHINE form a18 truncate
        col PROGRAM form a30 truncate
        break on INST_ID
        select INST_ID
		, SID
--		, SERIAL#
        	, STATUS
		, USERNAME
		, OSUSER
		, MACHINE
        	, PROCESS PROC
		, PROGRAM
		, to_char(LOGON_TIME,'DD/MM HH24:MI:SS') LOGON
        from gv\$session
        order by INST_ID, TYPE, STATUS, USERNAME;"
    return $?
    }

#---------------------------
# Print info about top CPU-using
# sessions in the database.
# Input : None
# Output: Info on stdout
#---------------------------
GetTopSessionInfo ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        80* )   echo "Top sessions information is currently not available for pre-8i databases"
            return 0;;
    esac

    RunSql2Html 999 "10 top database sessions - right now" "col USERNAME form a20
        col OSUSER form a12
        col MACHINE form a20 truncate
        col RANK form 99
        col SID form 999
        col PROGRAM form a25 truncate
        select a.INST_ID, ROWNUM as RANK, a.SID, a.USERNAME, a.OSUSER, a.MACHINE, a.PROGRAM, a.CPUMINS
        from (select v.INST_ID, v.SID, USERNAME, OSUSER, MACHINE, PROGRAM, round(v.VALUE/(100*60),0) CPUMINS
                from gv\$statname s , gv\$sesstat v, gv\$session sess
                where s.NAME = 'CPU used by this session'
                        and sess.SID = v.SID
                        and v.STATISTIC#=s.STATISTIC#
                        and v.VALUE > 0
                order by v.VALUE desc) a
        where rownum < 11;" || return $?

    return 0
    }

#---------------------------
# Print info about Suspended sessions
# Input : None
# Output: Info on stdout
#---------------------------
GetResumableSessions ()
    {
    case $DBINFO_DB_VERSION_SHORT in
        8*)	echo "Resumable sessions information is not available for pre-9i databases"
            return 0;;
    esac

    RunSql2Html 999 "Resumable database sessions" \
        "col NAME form a45
        col  SQL_TEXT form a120 truncate
        col ERROR_MSG form a60 truncate
        select SESSION_ID, NAME, STATUS, TIMEOUT, START_TIME, SUSPEND_TIME, SQL_TEXT, ERROR_MSG 
        from dba_resumable;";
    return $?
    }

#---------------------------
# Check to see if some of the
# most common login/password 
# strings are valid. 
# They really _really_ shouldn't be ...
#---------------------------
GetDefaultLogins ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "Depending on installed database options and demonstration schemas, an oracle"
        AddText info "database usually contains a number of users other than SYS and SYSTEM"
        AddText info "\nThis poses a problem, as the default passwords for these users often"
        AddText info "are not changed before the database is put into production."
        AddText info "In addition, several of the installed users are probably not"
        AddText info "needed in the database, and can safely be removed, or have"
        AddText info "their accounts locked."
        AddText info "\nNote that some applications may depend on default passwords to work,"
        AddText info "while others may require special routines for password changes."
        AddText info "\nAny username listed below should _probably_ have it's password changed by issuing:"
        AddText info "alter user USERNAME idenitifed by NEW_PASSWORD;\n"
    fi
    # Only run if script was called with '-pass' 
    if [ "$DBINFO_CHECK_PASSWORD" = "YES" ] ; then
    	if [ ! -r $DBINFO_PASSWORD_FILE ] ; then
        	echo "No password list found."
        	return 1
    	else
		# Get a list of usernames to check up against the password list
    		DBINFO_SCHEMAS=$(RunSql 0 - "select USERNAME from dba_users;") || return $?
		DBINFO_RETURNED_ROWS=0
		for m in $DBINFO_SCHEMAS ; do
			grep -E "^$m/" $DBINFO_PASSWORD_FILE | while read n ; do
				echo "select 'LOGGED_ON' from dual;" | sqlplus -s "$n" | grep -q "LOGGED_ON"
				if [ $? -eq 0 ] ; then
					AddText warning "User $(echo $n | cut -d"/" -f1) has a default or easy password. CHANGE IT!"
					let DBINFO_RETURNED_ROWS+=1
				fi
                	done
		done
    	fi
    	[ $DBINFO_RETURNED_ROWS -gt 0 ] && \
		echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS users with default passwords" >> $DBINFO_HTML_STATUS
    else
        AddText std "\nThis test has been disabled."
        AddText std "To enable it, please run this script again wityh the '-pass' option.\n"
    fi
    return 0
    }

#---------------------------
# Check to see if any users
# have _too_ easy passwords ...
# They really _really_ shouldn't have ...
#---------------------------
GetLazyLogins ()
    {
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        AddText info "A common password for a schema is the schema name. Needless to say - it should be changed."
        AddText info "\nAny username listed below should probably have it's password changed by issuing:"
        AddText info "alter user USERNAME identifed by NEW_PASSWORD;\n"
    fi

# Only run if script was called with '-pass'
    if [ "$DBINFO_CHECK_PASSWORD" = "YES" ] ; then
    	DBINFO_SCHEMAS=$(RunSql 0 - "select USERNAME from dba_users;") || return $?
    	DBINFO_RETURNED_ROWS=0
    	for n in $DBINFO_SCHEMAS ; do
        	echo "select 'LOGGED_ON' from dual;" | sqlplus -s $n/$n | grep -q "LOGGED_ON"
        	if [ $? -eq 0 ] ; then
            		AddText warning "User $n has a lazy password. CHANGE IT!"
            		let DBINFO_RETURNED_ROWS+=1
        	fi
    	done
    	[ $DBINFO_RETURNED_ROWS -gt 0 ] && \
		echo "$ORACLE_SID : Database has $DBINFO_RETURNED_ROWS users with lazy passwords" >> $DBINFO_HTML_STATUS
    else
        AddText std "\nThis test has been disabled."
        AddText std "To enable it, please run this script again wityh the '-pass' option.\n"
    fi
    return 0
    }

#---------------------------
# Show usage information
#---------------------------
Usage ()
    {
    echo "Usage : $(basename $0)"
    echo ""
    echo "FORMATTING:"
    echo ""
    echo "	-text	:	Dump output to stdout."
    echo "			 The default is to dump to html file"
    echo "	-file	:	Write html output to specified file."
    echo "			 The default is [hostname]_oracle_[datestamp].html"
    echo "	-htab	:	Create html-tables where possible."
    echo "			 This is the default."
    echo "	-nohtab	:	Do not create html-tables. Text only."
    echo "	-css 	:	Replace default css with link to specified css file (as seen from webserver)"
    echo ""
    echo "CONTENT:"
    echo ""
    echo "	-home	:	List out content of specified ORACLE_HOME only"
    echo "			 Alternative values are :"
    echo "				used	- Only list contents for ORACLE_HOME used by specified SIDS"
    echo "					  (All from oratab, or SIDS specified using the -sid option)"
    echo "					  This is the default behaviour."
    echo "			 	all	- List for all detected ORACLE_HOME installations"
    echo "	-nohome	:	Don't list out contents for any ORACLE_HOME"
    echo "	-sid	:	Run ora2html for given sids only. Specify sids as a comma-separated list."
    echo "			 The default is all sids in the system oratab."
    echo "	-nosid	:	Dont' run test for any databases."
    echo "	-info	:	Print extended information for tests where available."
    echo "	-noinfo	:	Don't print extended information for tests. (Default)"
    echo "	-pop 	:	Create html documents containing the sql code used by this collector."
    echo "                         Also creates links for popup windows that display the code"
    echo "	-nopop 	:	Turn of creation of popup links (Default)"
    echo "	-pass	:	Perform password checks on user accounts. (Default is NO password checking)"
    echo ""
    echo "MISC:"
    echo ""
    echo "	-sqllog	:	Log sql execution to file sql.log"
    echo "	-v	:	Show script version and exit."
    echo "	-h|-?	:	Show help screen."
    echo ""
    exit 0
    }

#---------------------------
# Parse the commandline
# -v  =  Show version and exit
#---------------------------
ParseCommandline ()
    {
    while [ $# -ne 0 ] ; do
    case $1 in
        -v) 		echo $DBINFO_VERSION
                exit 0;;
        -sid)		shift
                DBINFO_CHECKSIDS=$(echo $1 | sed 's/,/ /g');;
        -file)		shift 
                DBINFO_HTML_DOC=$1;;
        -htab)		DBINFO_HTML_TABLES=YES;;
        -nohtab)	DBINFO_HTML_TABLES=NO;;
        -text)		DBINFO_OUTPUT=TEXT;;
        -noinfo) 	DBINFO_EXPLAIN=NO;;
        -info)  	DBINFO_EXPLAIN=YES;;
        -sqllog) 	DBINFO_SQLLOG=YES;;
        -nosid)		DBINFO_NOSID=YES;;
        -home)		shift
                DBINFO_HOME=$1;;
	-nohome)	DBINFO_HOME=none;;
        -pop)		DBINFO_POP=YES;;
        -nopop)		DBINFO_POP=NO;;
	-pass)		DBINFO_CHECK_PASSWORD=YES;;
	-css)		shift
			DBINFO_CSS=$1;;
        -h|-?|-*help)	Usage;;
        *)		echo "Unrecognized option $1"
                Usage;;
    esac
    shift
    done
    }

#---------------------------
# Check if the database is RAC
# Return RAC sid if it is, 
# return "N/A" to stdout if not
#---------------------------
IsRac ()
    {
    # Check cluster_database parameter in v$parameters. 
    # If cluster_database='TRUE', return the db_name value
    OUT=$(RunSql 0 - "select VALUE from v\$parameter where NAME='db_name'
        and exists (select VALUE from  v\$parameter where NAME='cluster_database' and VALUE='TRUE');")
    if [ $? -eq 0 ] ; then
        if [ "$OUT" = "no rows selected" ] ; then
            return 0	
        else
            echo "$OUT"
        fi
    else
        return 1
    fi
    }

#---------------------------
# Get the database role from v$database
# Input  : none
# Return : 1 if check fails
# Output : ROLE name
#---------------------------
GetDbRole ()
    {
    # Check database_role from v$database
    OUT=$(RunSql 0 - "select DATABASE_ROLE from v\$database;")
    if [ $? -eq 0 ] ; then
        echo "$OUT"
        return 0
    else
        return 1
    fi
    }


#####################################################################
#####################################################################
#####                                                           #####
#####     F U N C T I O N S    F O R    R U N N I N G           #####
#####                                                           #####
#####                       E A C H                             #####
#####                                                           #####
#####                T E S T    S E C T I O N                   #####
#####                                                           #####
#####             ( Calls the functions above )                 #####
#####                                                           #####
#####   These funcs are here to move things out of the MAIN     #####
#####   section of the script. Each function runs a batch       #####
#####   of collect-jobs.                                        #####
#####   This makes the script much easier to read later ...     #####
#####                                                           #####
#####################################################################
#####################################################################
    
#---------------------------
# All Os & Hardware tests are run from here  
# There's no errorchecking in this function.
# It just runs all 1.* tests
#---------------------------
OsAndHardware ()
    {
        Exec H1 "1 - Basic system / platform information" 
        [ "$DBINFO_OUTPUT" = "HTML" ] && echo "<A HREF=\"#1 - Basic system / platform information\">[Server/OS info]</A>" >> $DBINFO_HTML_TOP
        if [ "$DBINFO_CHECK_OS" = "YES" ] ; then
            Exec H2 "1.1 - Server OS" GetOsInfo || Error $? "Unable to find basic OS information"
            Exec H2 "1.2 - Server platform" GetHwInfo || Error $? "Unable to find basic OS information"
            Exec H2 "1.3 - Server kernel IPC-parameters" GetKernelInfo || Error $? "Unable to find kernel parameter information"
            Exec H2 "1.4 - Server filesystem layout and status" GetDfInfo || Error $? "Unable to retrieve filesystem status"
        else
            AddText std "\nThis section has been disabled."
            AddText std "To enable it, change the parameter DBINFO_CHECK_OS to YES and re-run the collection script.\n"
        fi
    }

#---------------------------
# All Users & Environment tests are run from here  
# There's no errorchecking in this function.
# It just runs all 2.* tests
#---------------------------
UsersAndEnvironment ()
    {
	# Get info for current user 
        Exec H1 "2 - OS user configuration and environment"
        if [ "$DBINFO_CHECK_OSUSER" = "YES" ] ; then
            Exec H2 "2.1 - User $(whoami) basic information" GetOsUserInfo \
                || Error $? "Unable to get user environment for user oracle" 
            Exec H2 "2.2 - User $(whoami) environment" GetUserenv \
                || Error $? "Unable to get user environment for user oracle" 
            Exec H2 "2.3 - User $(whoami) crontab" GetCrontab \
                || Error $? "Unable to locate a crontab entry for user oracle"
            Exec H2 "2.4 - User $(whoami) OS-processes" GetUserProcs \
                || Error $? "Unable to retrieve active os-processes"
        else
            AddText std "\nThis section has been disabled."
            AddText std "To enable it, change the parameter DBINFO_CHECK_OSUSER to YES and re-run the collection script.\n"
        fi
    }
    
#---------------------------
# All installed sofware and special configuration  
# There's no errorchecking in this function.
# It just runs all 3.* tests
#---------------------------	
SoftwareAndComponents ()
    {
    Exec H1 "3 - Oracle software and components"
    Exec H2 "3.1 - System oraInst.loc" GetOraInv \
        || Error $? "Unable to locate an oraInst.loc entry for server $(uname -n)"
    Exec H2 "3.2 - System srvConfig.loc" GetSrvConfig \
        || Error $? "Unable to list contents of srvConfig.loc for server $(uname -n)"
    Exec H2 "3.3 - System oratab" GetOratab \
        || ExitScript $? "Unable to locate an oratab entry for server $(uname -n)"

    Exec H2 "3.4 - OS-users with admin rights on databases" GetOraUsers \
        || Error $? "Problems retrieveing oracle users"

    Exec H2 "3.5 - Detected installations" GetSwInstallations \
        || ExitScript $? "Unable to detect oracle home directories for server $(uname -n)"
    Exec H2 "3.6 - Common SQL*Net settings" 
    if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
        # Since we just have a section header here, without any content, the info text 
        # looks funny (no newline) unless we turn on the preformatting tag
        [ "$DBINFO_OUTPUT" = "HTML" ] && echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
        AddText info "SQL*Net related configuration is by default searched for in these locations:"
        AddText info " - \$TNS_ADMIN/"
        AddText info " - /etc/"
        AddText info " - /var/opt/oracle/"
        AddText info " - \$ORACLE_HOME/network/admin/"
        AddText info "\$TNS_ADMIN can be set in the user environment in a number of ways, and is not checked for in these tests."
        AddText info "The following tests searches through /etc and /var/opt/oracle for configuration files"
        AddText info "that can be considered shared/common for all ORACLE_HOME installastions on the server."
        [ "$DBINFO_OUTPUT" = "HTML" ] && echo "</PRE>\c" >> $DBINFO_HTML_BOTTOM
    fi
    Exec H3 "3.6.1 - Shared listener configuration" GetListenerConfigShared \
        || Error $? "Unable to list shared configuration for listener"
    Exec H3 "3.6.2 - Shared listener security" GetListenerSecurityShared \
        || Error $? "Unable to collect shared listener security information"
    Exec H3 "3.6.3 - Shared SQL*Net configuration" GetSqlnetConfigShared \
        || Error $? "Unable to find shared SQL*Net config file"
    Exec H3 "3.6.4 - Shared Tnsnames configiration" GetTnsnamesConfigShared \
        || Error $? "Unable to find shared tnsnames file"

    typeset -i DBINFO_COUNTER=6

    # Sort out which ORACLE_HOME to list contents for. Default value is 'all'
    # 'used' depends on wether -sid has been specified
    case $DBINFO_HOME in
        none)	AddText std "\nNot checking any ORACLE_HOMEs due to '-home none' option"
            DBINFO_ORACLE_HOMES="";;
        used)	if [ "$DBINFO_CHECKSIDS" = "" ] ; then
                export DBINFO_ORACLE_HOMES="$DBINFO_OHALL"
            else
                export DBINFO_ORACLE_HOMES=""
                for i in $DBINFO_CHECKSIDS ; do
                    DBINFO_ORACLE_HOMES="$DBINFO_ORACLE_HOMES\n$(grep -E "^$i:" $DBINFO_ORATAB | cut -d":" -f2)"
                done
                # Remove duplicates and empty lines
                DBINFO_ORACLE_HOMES=$(echo "$DBINFO_ORACLE_HOMES" | grep -v -E "^$" | sort -u)
            fi;;
        all)	export DBINFO_ORACLE_HOMES="$DBINFO_OHALL";;
        *)	if [ -d $DBINFO_HOME ] ; then
                DBINFO_ORACLE_HOMES="$DBINFO_HOME"
            else
                AddText std "\nContents listing for ORACLE_HOME $DBINFO_HOME specified, but it's not present!"
                echo "$DBINFO_HOME : Explicity specified for contents listing, but NOT present" >> $DBINFO_HTML_STATUS
                DBINFO_ORACLE_HOMES=""
            fi;;
    esac

    for ORACLE_HOME in $DBINFO_ORACLE_HOMES ; do
        let DBINFO_COUNTER+=1
        Exec H2 "3.$DBINFO_COUNTER - Components and config for ORACLE_HOME=$ORACLE_HOME"

        if [ "$DBINFO_CHECK_COMPONENTS" = "YES" ] ; then
            Exec H3 "3.$DBINFO_COUNTER.1 - $ORACLE_HOME : Installed products" GetInstalledProducts \
                || Error $? "Unable to find a list of installed products for $ORACLE_HOME"
            Exec H3 "3.$DBINFO_COUNTER.2 - $ORACLE_HOME : Installed adapters" GetInstalledAdapters \
                || Error $? "Unable to find a list of installed adapters for $ORACLE_HOME"
            Exec H3 "3.$DBINFO_COUNTER.3 - $ORACLE_HOME : SQL*Net settings"
            if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
                # Since we just have a section header here, without any content, the info text 
                # looks funny (no newline) unless we turn on the preformatting tag
                [ "$DBINFO_OUTPUT" = "HTML" ] && echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
                AddText info "SQL*Net related configuration is by default searched for in these locations:"
                AddText info " - \$TNS_ADMIN/"
                AddText info " - /etc/"
                AddText info " - /var/opt/oracle/"
                AddText info " - \$ORACLE_HOME/network/admin/"
                AddText info "\$TNS_ADMIN can be set in the user environment in a number of ways, and is not checked for in these tests."
                AddText info "If a shared/common config file has been found earlier on (section 3.4.*), no further tests are done here."
                AddText info "If not, \$ORACLE_HOME/network/admin is searched for configuration files spesific to this ORACLE_HOME"
                # And off with the preformatting tag
                [ "$DBINFO_OUTPUT" = "HTML" ] && echo "</PRE>\c" >> $DBINFO_HTML_BOTTOM
            fi
            Exec H3 "3.$DBINFO_COUNTER.3.1 - $ORACLE_HOME : Listener configuration" GetListenerConfig \
                || Error $? "Unable to find configuration for listener"
            Exec H3 "3.$DBINFO_COUNTER.3.2 - $ORACLE_HOME : Listener security information" GetListenerSecurity \
                || Error $? "Unable to collect listener security information"
            Exec H3 "3.$DBINFO_COUNTER.3.3 - $ORACLE_HOME : SQL*Net configuration" GetSqlnetConfig \
                || Error $? "Unable to find SQL*Net config file"
            Exec H3 "3.$DBINFO_COUNTER.3.4 - $ORACLE_HOME : Tnsnames" GetTnsnamesConfig \
                || Error $? "Unable to find configuration-file for name lookup"
        else
            AddText std "\nThis section has been disabled."
            AddText std "To enable it, change the parameter DBINFO_CHECK_COMPONENTS to YES and re-run the collection script.\n"
        fi
    done
    }

#---------------------------
# All tests related to internal oracle stuff  
# There's no errorchecking in these functions.
# They just run all 4++.* tests
#---------------------------	

# Config files and Logfiles - Section *.1.*
ConfigAndLogfiles ()
    {
    ################################
    #
    # Set the correct RDBMS version. 
    # Some SQL's are version spesific, 
    # and we neeed this to select what to run
    #
    ################################
    export DBINFO_DB_VERSION_SHORT=$(sqlplus -? | grep "Plus: Release" \
        | awk '{print $3}' | sed 's/\.//g' | cut -c1-3)

    ################################
    #
    # Store the database role (primary, physical standby ...
    # We really don't use this value for anything yet - it's just for info
    #
    ################################
    export DBINFO_DB_ROLE=$(GetDbRole) || Error $? "Unable to decide database role for $ORACLE_SID"

    ################################
    #
    # Check if this is RAC. Value is empty if it's not. 
    # Any other value is the value of DB_NAME in v$parameter
    # We really don't use this value for anything - it's just for info
    #
    ################################
    export DBINFO_RAC_NAME=$(IsRac) || Error $? "Unable to decide RAC/no-RAC status of $ORACLE_SID"

    # Just for information:
    # 1) We're on a standby database
    # 2) We're on "normal" database (in this case that means we're not on RAC or physical standby)
    # 3) We're on RAC
    if [ "$DBINFO_DB_ROLE" = "PHYSICAL STANDBY" ] ; then
        Exec H1 "$DBINFO_COUNTER - Physical Standby Database $ORACLE_SID ($ORACLE_HOME)"
        [ "$DBINFO_OUTPUT" = "HTML" ] \
            && echo "<A HREF=\"#$DBINFO_COUNTER - Physical Standby Database $ORACLE_SID ($ORACLE_HOME)\">[$ORACLE_SID]</A>" >> $DBINFO_HTML_TOP
#		[ "$DBINFO_OUTPUT" = "HTML" ] && echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
#		if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
#			AddText info "\nNeed som physical standby information here ;-).\n"
#		fi
#		[ "$DBINFO_OUTPUT" = "HTML" ] && echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
    elif [ "$DBINFO_RAC_NAME" = "" ] ; then
        Exec H1 "$DBINFO_COUNTER - Database $ORACLE_SID ($ORACLE_HOME)"
        [ "$DBINFO_OUTPUT" = "HTML" ] \
            && echo "<A HREF=\"#$DBINFO_COUNTER - Database $ORACLE_SID ($ORACLE_HOME)\">[$ORACLE_SID]</A>" >> $DBINFO_HTML_TOP
    else
        Exec H1 "$DBINFO_COUNTER - RAC Database $DBINFO_RAC_NAME ($ORACLE_SID - $ORACLE_HOME)"
        [ "$DBINFO_OUTPUT" = "HTML" ] \
            && echo "<A HREF=\"#$DBINFO_COUNTER - RAC Database $DBINFO_RAC_NAME ($ORACLE_SID - $ORACLE_HOME)\">[$DBINFO_RAC_NAME]</A>" >> $DBINFO_HTML_TOP
        [ "$DBINFO_OUTPUT" = "HTML" ] && echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
        if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
            AddText info "Oracle Real Application Cluster (RAC) is a clustering solution where a database"
            AddText info "can be run on several physical servers at the same time." 
            AddText info "Syncronization between each instance that make up the database is performed"
            AddText info "using high-speed interconnect solutions (GbLan, Fibre Channel, etc.)"
            AddText info "Some of the benfits offered by RAC are increased fault tolerance,"
            AddText info "improved scalability and load balancing.\n"
        fi
        AddText warning "\nThe information offered here may NOT reflect the entire/correct RAC configuration!"
        AddText warning "Most information displayed is grouped by instance number where possible. Where instance"
        AddText warning "number is not displayed, assume the information is for the local instance only.\n"
        [ "$DBINFO_OUTPUT" = "HTML" ] && echo "<PRE>\c" >> $DBINFO_HTML_BOTTOM
    fi


    # Initialize empty variables for this db
    export DBINFO_SPFILE=""
    export DBINFO_PFILE=""
    export DBINFO_IFILE=""
            
    Exec H2 "$DBINFO_COUNTER.1 - $ORACLE_SID : Database configuration and logfile"
    Exec H3 "$DBINFO_COUNTER.1.1 - $ORACLE_SID : System parameter file (spfile)" GetSpFile \
        || Error $? "Unable to find database spfile"
    Exec H3 "$DBINFO_COUNTER.1.2 - $ORACLE_SID : Parameter file (pfile)" GetPFile \
        || Error $? "Unable to find database pfile"
    Exec H3 "$DBINFO_COUNTER.1.3 - $ORACLE_SID : Config file (ifile)" GetIFile \
        || Error $? "Unable to find database ifile"
    # Skip this one. It's not that interesting.
    #Exec H3 "$DBINFO_COUNTER.1.4 - $ORACLE_SID : Last 100 entires in alertlog" GetAlertlog \
    #	|| Error $? "Unable to find last entires of alertlog"
    }

# Database internal setup - Section *.2.*
DatabaseSetup ()
    {	
    Exec H2 "$DBINFO_COUNTER.2 - $ORACLE_SID : Internal database setup and configuration"
    if [ "$DBINFO_CHECK_BASIC_DB" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.2.1 - $ORACLE_SID : Basic instance information" GetSidInfo \
            || Error $? "Unable to collect basic db-info for database $ORACLE_SID"
        Exec H3 "$DBINFO_COUNTER.2.2 - $ORACLE_SID : License information" GetLicenseInfo \
            || Error $? "Unable to collect instance license information"
        Exec H3 "$DBINFO_COUNTER.2.3 - $ORACLE_SID : Available database products and options" GetOptionInfo \
            || Error $? "Unable to list available database options"
        Exec H3 "$DBINFO_COUNTER.2.4 - $ORACLE_SID : NLS Parameters" GetNlsParameters \
            || Error $? "Unable to collect NLS information from database"
        Exec H3 "$DBINFO_COUNTER.2.5 - $ORACLE_SID : System Global Area - SGA" GetSgaInfo \
            || Error $? "Unable to collect SGA information for database $ORACLE_SID"
        Exec H4 "$DBINFO_COUNTER.2.5.1 - $ORACLE_SID : SGA - Shared Pool" GetSharedPoolInfo \
            || Error $? "Unable to collect Shared Pool information for database $ORACLE_SID"
        Exec H4 "$DBINFO_COUNTER.2.5.2 - $ORACLE_SID : SGA - Buffer Cache" GetBufferCacheInfo \
            || Error $? "Unable to collect Buffer Cache information for database $ORACLE_SID"
        Exec H4 "$DBINFO_COUNTER.2.5.3 - $ORACLE_SID : SGA - Misc information" GetSgaMiscInfo \
            || Error $? "Unable to collect Misc SGA information for database $ORACLE_SID"
        Exec H3 "$DBINFO_COUNTER.2.6 - $ORACLE_SID : Program Global Area - PGA" GetPgaInfo \
            || Error $? "Unable to collect PGA information for database $ORACLE_SID"
        Exec H3 "$DBINFO_COUNTER.2.7 - $ORACLE_SID : Non-default database parameters" GetParameters \
            || Error $? "Unable to get non-default system parameters for database $ORACLE_SID"
        Exec H3 "$DBINFO_COUNTER.2.8 - $ORACLE_SID : Runtime modified database parameters" GetAdjParameters \
            || Error $? "Unable to get adjusted system parameters for database $ORACLE_SID"
    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_BASIC_DB to YES and re-run the collection script.\n"
    fi
    }
    
# Database storage and datafiles - Section *.3.*
DatabaseStorage ()
    {
    Exec H2 "$DBINFO_COUNTER.3 - $ORACLE_SID : Datafiles and storage setup"
    if [ "$DBINFO_CHECK_STORAGE" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.3.1 - $ORACLE_SID : Archive information" GetArchiveInfo \
            || Error $? "Unable to collect archiver information for database $ORACLE_SID"
        Exec H3 "$DBINFO_COUNTER.3.2 - $ORACLE_SID : Database controlfiles" GetControlFiles \
            || Error $? "Unable to list database controlfile dump"
        Exec H3 "$DBINFO_COUNTER.3.3 - $ORACLE_SID : Database redolog files" GetRedologFiles \
            || Error $? "Unable to collect redolog information"
        Exec H3 "$DBINFO_COUNTER.3.4 - $ORACLE_SID : Rollback segments" GetRbsInfo \
            || Error $? "Unable to collect RBS info"
        Exec H3 "$DBINFO_COUNTER.3.5 - $ORACLE_SID : Undo segments" GetUndoInfo \
            || Error $? "Unable to collect undo tablespace info"
        Exec H3 "$DBINFO_COUNTER.3.6 - $ORACLE_SID : Tablespaces"
        Exec H4 "$DBINFO_COUNTER.3.6.1 - $ORACLE_SID : Tablespace summary" GetTablespaceInfo \
            || Error $? "Unable to collect tablespace summary information"
        Exec H4 "$DBINFO_COUNTER.3.6.2 - $ORACLE_SID : Tablespace increases" GetTablespaceIncreases \
            ||  Error $? "Unable to collect tablespace increase information"
        Exec H4 "$DBINFO_COUNTER.3.6.3 - $ORACLE_SID : Temporary tablespaces" GetTempTablespaces \
            || Error $? "Unable to collect information about temp tablespaces"
        Exec H4 "$DBINFO_COUNTER.3.6.4 - $ORACLE_SID : Transportable tablespaces" GetTransTablespaces \
            || Error $? "Unable to collect information about transportable tablespaces"
        Exec H4 "$DBINFO_COUNTER.3.6.5 - $ORACLE_SID : Bigfile tablespaces" GetBigfileTablespaces \
            || Error $? "Unable to collect information about bigfile tablespaces"
        Exec H4 "$DBINFO_COUNTER.3.6.6 - $ORACLE_SID : Tablespace fragmentation" GetTablespaceFragmentation \
            || Error $? "Unable to collect tablespace framgentation info"
#        Exec H4 "$DBINFO_COUNTER.3.6.3 - $ORACLE_SID : Tablespaces not listed as online" GetTablespaceStatus \
#            || Error $? "Unable to collect tablespace status information"
#        Exec H4 "$DBINFO_COUNTER.3.6.5 - $ORACLE_SID : Locally managed tablespaces" GetLocalTablespaces \
#            || Error $? "Unable to collect information about locally managed tablespaces"

        Exec H3 "$DBINFO_COUNTER.3.7 - $ORACLE_SID : Datafiles"
        Exec H4 "$DBINFO_COUNTER.3.7.1 - $ORACLE_SID : Datafile summary" GetDatafileInfo \
            || Error $? "Unable to collect datafile summary information"
        Exec H4 "$DBINFO_COUNTER.3.7.2 - $ORACLE_SID : Datafiles with autoextend enabled" GetDatafileAutoextend \
            || Error $? "Unable to collect datafile autoextend info"
        Exec H4 "$DBINFO_COUNTER.3.7.3 - $ORACLE_SID : Datafiles not listed as online" GetDatafileAvailibility \
            || Error $? "Unable to collect datafile availibility info"
        Exec H4 "$DBINFO_COUNTER.3.7.4 - $ORACLE_SID : Datafile Corruption" GetFileCorruption \
            || Error $? "Unable to collect datafile corruption information"
#        Exec H4 "$DBINFO_COUNTER.3.7.4 - $ORACLE_SID : Datafile IO information" GetFileIO \
#            || Error $? "Unable to collect datafile IO information"
    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_STORAGE to YES and re-run the collection script.\n"
    fi
    }

# Database Users and Roles - Section *.4.*
DatabaseUsersAndRoles ()
    {
    Exec H2 "$DBINFO_COUNTER.4 - $ORACLE_SID : Users and Roles"
    if [ "$DBINFO_CHECK_USERS" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.4.1 - $ORACLE_SID : Users" GetUsersInfo \
            || Error $? "Unable to collect user information"
        Exec H3 "$DBINFO_COUNTER.4.2 - $ORACLE_SID : User tablespace quotas" GetTsQuota \
            || Error $? "Unable to collect tablespace storage quotas"
        Exec H3 "$DBINFO_COUNTER.4.3 - $ORACLE_SID : Roles" GetRoleInfo \
            || Error $? "Unable to collect role information"
        Exec H3 "$DBINFO_COUNTER.4.4 - $ORACLE_SID : DB Jobs" GetDBJobs \
            || Error $? "Unable to collect DB jobs information"
    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_USERS to YES and re-run the collection script.\n"
    fi
    }

# Database Objects - Section *.5.*
DatabaseObjects ()
    {
    Exec H2 "$DBINFO_COUNTER.5 - $ORACLE_SID : Database objects"
    if [ "$DBINFO_CHECK_OBJECTS" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.5.1 - $ORACLE_SID : Summary of objects by user" GetObjectInfo \
            || Error $? "Unable to collect object information"
        Exec H3 "$DBINFO_COUNTER.5.2 - $ORACLE_SID : Invalid objects" GetInvalidObjects \
            || Error $? "Unable to collect object status information"
        Exec H3 "$DBINFO_COUNTER.5.3 - $ORACLE_SID : Directories" GetDirectoryInfo \
            || Error $? "Unable to collect directory information"
        Exec H3 "$DBINFO_COUNTER.5.4 - $ORACLE_SID : External tables" GetExternalTableInfo \
            || Error $? "Unable to collect external table information"
        Exec H3 "$DBINFO_COUNTER.5.5 - $ORACLE_SID : Snapshots / Materialized views" GetSnapshotInfo \
            || Error $? "Unable to collect table snapshot information"
        Exec H3 "$DBINFO_COUNTER.5.6 - $ORACLE_SID : Large segments"
        Exec H4 "$DBINFO_COUNTER.5.6.1 - $ORACLE_SID : Largest unpartitoned tables" GetLargeTabInfo \
            || Error $? "Unable to collect object status information"
        Exec H4 "$DBINFO_COUNTER.5.6.2 - $ORACLE_SID : Largest unpartitoned indexes" GetLargeIndInfo \
            || Error $? "Unable to collect object status information"
        Exec H3 "$DBINFO_COUNTER.5.7 - $ORACLE_SID : Partitioned segments"
        Exec H4 "$DBINFO_COUNTER.5.7.1 - $ORACLE_SID : Partitoned tables" GetTabPartInfo \
            || Error $? "Unable to collect table partition information"
        Exec H4 "$DBINFO_COUNTER.5.7.2 - $ORACLE_SID : Partitoned indexes" GetIndPartInfo \
            || Error $? "Unable to collect table partition information"
        Exec H3 "$DBINFO_COUNTER.5.8 - $ORACLE_SID : Interesting segments"
        Exec H4 "$DBINFO_COUNTER.5.8.1 - $ORACLE_SID : Segments that should be relocated" GetRelocSegs \
            || Error $? "Unable to collect segs. relocation candidates"
        Exec H4 "$DBINFO_COUNTER.5.8.2 - $ORACLE_SID : Segments reaching max extents" GetMaxExtents \
            || Error $? "Unable to collect segs. reaching maxextents"
        Exec H4 "$DBINFO_COUNTER.5.8.3 - $ORACLE_SID : Segments with high # extents" GetExcessiveExtents \
            ||  Error $? "Unable to collect overextended segs."
        Exec H4 "$DBINFO_COUNTER.5.8.4 - $ORACLE_SID : Chaining and migration" GetChainingInfo \
            || Error $? "Unable to collect table chaining/migration information"
        Exec H4 "$DBINFO_COUNTER.5.8.5 - $ORACLE_SID : Sysaux objects" GetSysauxInfo \
            || Error $? "Unable to collect sysaux information"
#        Exec H4 "$DBINFO_COUNTER.5.8.4 - $ORACLE_SID : Segments unable to allocate next extent" GetNextExtent \
#            || Error $? "Unable to collect segs. unable to increase"


    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_OBJECTS to YES and re-run the collection script.\n"
    fi
    }

# Current Sessions - Section *.6.*	
CurrentSessions ()
    {
    Exec H2 "$DBINFO_COUNTER.6 - $ORACLE_SID : Database sessions"
    if [ "$DBINFO_CHECK_SESSIONS" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.6.1 - $ORACLE_SID : Current sessions" GetSessionInfo \
            || Error $? "Unable to collect session information"
        Exec H3 "$DBINFO_COUNTER.6.2 - $ORACLE_SID : Top CPU users" GetTopSessionInfo \
            || Error $? "Unable to collect top usage information"
        Exec H3 "$DBINFO_COUNTER.6.3 - $ORACLE_SID : Resumable sessions" GetResumableSessions \
            || Error $? "Unable to collect suspended session information"
    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_SESSIONS to YES and re-run the collection script.\n"
    fi
    }

# Security overview and summary - Section *.7.*
SecurityOverview ()
    {
    Exec H2 "$DBINFO_COUNTER.7 - $ORACLE_SID : Security overview"
    if [ "$DBINFO_CHECK_SECURITY" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.7.1 - $ORACLE_SID : Oracle security parameters" GetSecParameters \
            || Error $? "Unable to collect security-related parameters"
        Exec H3 "$DBINFO_COUNTER.7.2 - $ORACLE_SID : Profile security information" GetProfileSettings \
            || Error $? "Unable to profile security information"
        Exec H3 "$DBINFO_COUNTER.7.3 - $ORACLE_SID : Database password file users" GetPwFileUsers \
            || Error $? "Unable to collect password file information"
        Exec H3 "$DBINFO_COUNTER.7.4 - $ORACLE_SID : Users authenticated externally" GetBadUsers \
            || Error $? "Unable to collect user auth. information"
        Exec H3 "$DBINFO_COUNTER.7.5 - $ORACLE_SID : Users/roles with worrying roles granted" GetBadRoles \
            || Error $? "Unable to collect bad role information"
        Exec H3 "$DBINFO_COUNTER.7.6 - $ORACLE_SID : Users/roles with worrying privs granted" GetBadPrivs \
            || Error $? "Unable to collect bad privs. information"
        Exec H3 "$DBINFO_COUNTER.7.7 - $ORACLE_SID : Default and easy logins" GetDefaultLogins \
            || Error $? "Unable to collect information about default logins"
        Exec H3 "$DBINFO_COUNTER.7.8 - $ORACLE_SID : Lazy logins" GetLazyLogins \
            || Error $? "Unable to collect information about too easy logins"
    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_SECURITY to YES and re-run the collection script.\n"
    fi
    }

# Recovery manager information and configuration - Section *.8.*
RMANInfo ()
    {
    Exec H2 "$DBINFO_COUNTER.8 - $ORACLE_SID : Recovery Manager (RMAN)"
    if [ "$DBINFO_CHECK_RMAN" = "YES" ] ; then
        Exec H3 "$DBINFO_COUNTER.8.1 - $ORACLE_SID : RMAN Configuration" GetRmanConfig 
        if [ $? -eq 1 ] ; then
            Error $? "Unable to collect RMAN info"
        elif [ $? -eq 2 ] ; then
            AddText std "Skipping further RMAN checks."
            return 0
        fi
    else
        AddText std "\nThis section has been disabled."
        AddText std "To enable it, change the parameter DBINFO_CHECK_RMAN to YES and re-run the collection script.\n"
    fi
    }

#---------------------------
# Check wether this database seem to use RMAN 
# for backup. Check basic config if so.
#---------------------------
GetRmanConfig()
    {
        if [ "$DBINFO_EXPLAIN" = "YES" ] ; then
                AddText info "Recovery manager (RMAN) is an Oracle-provided utility for performing database backup and restore/recovery."
        AddText info "It was introduced in Oracle v.8, and has evolved into a solution that offers features like incremental backup,"
        AddText info "multi-level restore and recovery (database, tablespace, datafile, datablock), database cloning, OS-independent restore..."
        AddText info "RMAN integrates with several external tape-library management solutions, and also with Oracle's ASM storage nodes"
        AddText info ""
        fi

    RunSql 999 "Check if Rman is used" "\
        select 'RMAN IN USE' 
	from v\$controlfile_record_section 
        where type like '%BACKUP%' 
        and records_used <> 0;" | grep -q "RMAN IN USE" 

    if [ $? -eq 0 ] ; then
        AddText std "Based on the contents of v\$controlfile_record_section, RMAN seems to be in use on this database."
        echo
        RunSql2Html 999 "v\$controlfile_record_section" "\
            select type, records_total, records_used
            from 	v\$controlfile_record_section
            where 	type LIKE '%BACKUP%'
            and 	records_used <> 0;" || return 1
        echo 
        RunSql2Html 999 "Supported backup devices (excl. DISK)" "\
            col DEVICE_TYPE form a12
            col DEVICE_NAME form a30
            select * from v\$backup_device;" || return 1
        echo
        RunSql2Html 999 "v\$rman_configuration" "\
            col NAME form a30
            col VALUE form a10
            select * from v\$rman_configuration;" || return 1
        echo 

        case $DBINFO_DB_VERSION_SHORT in
            1*)	RunSql2Html 999 "Block change tracking" "\
            col FILENAME form a90
            select * from v\$block_change_tracking;" || return 1 ;;
            *)	AddText std "Block change tracking is not available for database versions prior to 10g";;
        esac

        echo

    # Check these SQL's ..... Somebody should get credit
        RunSql2Html 999 "Last controlfile copies" "\
            col HANDLE form a50
            select * from (
                select
                    bp.device_type
                    , decode(   bs.CONTROLFILE_INCLUDED
                                , 'NO', '-'
                        , bs.CONTROLFILE_INCLUDED) CONTROLFILE_INCLUDED
                    , to_char(bs.COMPLETION_TIME, 'DD-MON-YYYY HH24:MI:SS')  COMPLETION_TIME
                    , decode(   STATUS
                                , 'A', 'Available'
                                , 'D', 'Deleted'
                                , 'X', 'Expired')   STATUS
                    , HANDLE            HANDLE
                from
                        v\$backup_set    bs
                    , v\$backup_piece  bp
                where
                        bs.SET_STAMP = bp.SET_STAMP
                    and bs.SET_COUNT = bp.SET_COUNT
                    and bp.STATUS in ('A')
                    and bs.CONTROLFILE_INCLUDED != 'NO'
                order by
			 bs.RECID desc
                    	, PIECE#  
                )
            where rownum < 20;" || return 1
        echo
        RunSql2Html 999 "Last spfile copies" "\
            col HANDLE form a50
            select * from (
                select
                bp.DEVICE_TYPE
                , sp.SPFILE_INCLUDED            SPFILE_INCLUDED
                , to_char(bs.COMPLETION_TIME, 'DD-MON-YYYY HH24:MI:SS')  COMPLETION_TIME
                , decode(   STATUS
                            , 'A', 'Available'
                            , 'D', 'Deleted'
                            , 'X', 'Expired')	STATUS
                , HANDLE                 	HANDLE
                from
                    v\$backup_set bs
                , v\$backup_piece bp
                , (select distinct
                        SET_STAMP
                        , SET_COUNT
                        , 'YES'     		SPFILE_INCLUDED
                    from v\$backup_spfile) sp
                where
                    bs.SET_STAMP = bp.SET_STAMP
                and bs.SET_COUNT = bp.SET_COUNT
                and bp.STATUS in ('A')
                and bs.SET_STAMP = sp.SET_STAMP
                and bs.SET_COUNT = sp.SET_COUNT
                order by
                    bs.RECID desc
                , PIECE#
                )
                where rownum < 20;" || return 1
    else
        AddText std "Based on the contents of v\$controlfile_record_section, RMAN doesn't seems to be in use on this database."
        return 2
    fi
    return 0
    }




#####################################################################
#####################################################################
#####                                                           #####
#####                      M  A  I N                            #####
#####                                                           #####
#####################################################################
#####################################################################

ParseCommandline $*

MkDir || ExitScript 1 "Unable to setup required directories"



# Print header based on which output mode we'll use
if [ "$DBINFO_OUTPUT" = "HTML" ] ; then
    HtmlHeader || ExitScript $? "Unable to print html header"
    echo "============================================================================"
    echo "ora2html version $DBINFO_VERSION"
    echo "Server  : $(uname -n)"
    echo "Started : $(date)"
    echo "============================================================================"
else
    echo "\nOracle database report for server $(uname -n)\n$(date)\n"
fi

################################
# OS and Hardware section starts here
# Section 1.*
################################
OsAndHardware

################################
# User setup and environment
# Assuming user oracle and dba group dba
# Section 2.*
################################
UsersAndEnvironment
    
################################
# Installed oracle components and basic configuration
# - Lists out info from each installed ORACLE_HOME
# Section 3.*
################################
SoftwareAndComponents

################################
# Oracle configuration and internal database setup
# (Test from here on can only be performed on open databases)
# Sections 4+++
################################
typeset -i DBINFO_COUNTER=3

if [ ! "$DBINFO_CHECK_DB" = "YES" ] ; then
    AddText std "\nTests that collect internal oracle server information have been disabled."
    AddText std "To enable them, change the parameter DBINFO_CHECK_DB to YES and re-run the collection script.\n"
else
    # Check specified sids (if any).
    # If no sids are specified on the commandline, list all oracle sids for this oracle home
    if [ "$DBINFO_CHECKSIDS" = "" ] ; then
        export DBINFO_ORACLE_SIDS=$(grep -v -E "^$|^#|^\*" $DBINFO_ORATAB | cut -d":" -f1)
    else
        export DBINFO_ORACLE_SIDS="$DBINFO_CHECKSIDS"
    fi
    if [ "$DBINFO_NOSID" = "YES" ] ; then
        AddText std "\nNot checking any databases due to -nosid option"
        DBINFO_ORACLE_SIDS=""
    fi
    for ORACLE_SID in $DBINFO_ORACLE_SIDS ; do
        let DBINFO_COUNTER+=1
        GetSidEnvironment $ORACLE_SID
        CheckDbStatus
        if [ $? -eq 1 ] ; then
# The next few lines just provide slightly nicer report output if the database isn't found running
            Exec H1 "$DBINFO_COUNTER - Database $ORACLE_SID ($ORACLE_HOME)"
            [ "$DBINFO_OUTPUT" = "HTML" ] \
                && echo "<A HREF=\"#$DBINFO_COUNTER - Database $ORACLE_SID ($ORACLE_HOME)\">[$ORACLE_SID]</A>" >> $DBINFO_HTML_TOP
            Error 1 "The instance $ORACLE_SID is not running. Skipping pending tests."
        else
            ################################
            # Database config and log files
            # Section *.1.*
            ################################
            ConfigAndLogfiles

            ################################
            # Database internal setup
            # Section *.2.*
            ################################
            DatabaseSetup
        
            ################################
            # Database storage setup and datafiles
            # Section *.3.*
            ################################
            DatabaseStorage

            ################################
            # Database users and roles
            # Section *.4.*
            ################################
            DatabaseUsersAndRoles

            ################################
            # Database objects
            # Section *.5.*
            ################################
            DatabaseObjects

            ################################
            # Current sessions
            # Section *.6.*
            ################################
            CurrentSessions

            ################################
            # Security and access related section
            # - Note that some of this info has already been shown in other sections
            # - Listener security is listed in the listener section
            # Section *.7.*
            ################################
            SecurityOverview

            ################################
            # Recovery manager section
            # Section *.8.*
            ################################
            RMANInfo

        fi
    done
fi	

[ $DBINFO_ERRORS -ne 0 ] && ExitScript $DBINFO_ERRORS "Problems encountered while running script"
ExitScript 0 "Script terminates successfully"



